"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/q";
exports.ids = ["vendor-chunks/q"];
exports.modules = {

/***/ "(action-browser)/./node_modules/q/q.js":
/*!*****************************!*\
  !*** ./node_modules/q/q.js ***!
  \*****************************/
/***/ ((module) => {

eval("\n// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ (function(definition) {\n    \"use strict\";\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n    // CommonJS\n    } else if (true) {\n        module.exports = definition();\n    // RequireJS\n    } else { var previousQ, global; }\n})(function() {\n    \"use strict\";\n    var hasStacks = false;\n    try {\n        throw new Error();\n    } catch (e) {\n        hasStacks = !!e.stack;\n    }\n    // All code after this point will be filtered from stack traces reported\n    // by Q.\n    var qStartingLine = captureLine();\n    var qFileName;\n    // shims\n    // used for fallback in \"allResolved\"\n    var noop = function() {};\n    // Use the fastest possible means to execute a task in a future turn\n    // of the event loop.\n    var nextTick = function() {\n        // linked list of tasks (single, with head node)\n        var head = {\n            task: void 0,\n            next: null\n        };\n        var tail = head;\n        var flushing = false;\n        var requestTick = void 0;\n        var isNodeJS = false;\n        // queue for late tasks, used by unhandled rejection tracking\n        var laterQueue = [];\n        function flush() {\n            /* jshint loopfunc: true */ var task, domain;\n            while(head.next){\n                head = head.next;\n                task = head.task;\n                head.task = void 0;\n                domain = head.domain;\n                if (domain) {\n                    head.domain = void 0;\n                    domain.enter();\n                }\n                runSingle(task, domain);\n            }\n            while(laterQueue.length){\n                task = laterQueue.pop();\n                runSingle(task);\n            }\n            flushing = false;\n        }\n        // runs a single function in the async queue\n        function runSingle(task, domain) {\n            try {\n                task();\n            } catch (e) {\n                if (isNodeJS) {\n                    // In node, uncaught exceptions are considered fatal errors.\n                    // Re-throw them synchronously to interrupt flushing!\n                    // Ensure continuation if the uncaught exception is suppressed\n                    // listening \"uncaughtException\" events (as domains does).\n                    // Continue in next event to avoid tick recursion.\n                    if (domain) {\n                        domain.exit();\n                    }\n                    setTimeout(flush, 0);\n                    if (domain) {\n                        domain.enter();\n                    }\n                    throw e;\n                } else {\n                    // In browsers, uncaught exceptions are not fatal.\n                    // Re-throw them asynchronously to avoid slow-downs.\n                    setTimeout(function() {\n                        throw e;\n                    }, 0);\n                }\n            }\n            if (domain) {\n                domain.exit();\n            }\n        }\n        nextTick = function(task) {\n            tail = tail.next = {\n                task: task,\n                domain: isNodeJS && process.domain,\n                next: null\n            };\n            if (!flushing) {\n                flushing = true;\n                requestTick();\n            }\n        };\n        if (typeof process === \"object\" && process.toString() === \"[object process]\" && process.nextTick) {\n            // Ensure Q is in a real Node environment, with a `process.nextTick`.\n            // To see through fake Node environments:\n            // * Mocha test runner - exposes a `process` global without a `nextTick`\n            // * Browserify - exposes a `process.nexTick` function that uses\n            //   `setTimeout`. In this case `setImmediate` is preferred because\n            //    it is faster. Browserify's `process.toString()` yields\n            //   \"[object Object]\", while in a real Node environment\n            //   `process.toString()` yields \"[object process]\".\n            isNodeJS = true;\n            requestTick = function() {\n                process.nextTick(flush);\n            };\n        } else if (typeof setImmediate === \"function\") {\n            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n            if (false) {} else {\n                requestTick = function() {\n                    setImmediate(flush);\n                };\n            }\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // modern browsers\n            // http://www.nonblocking.io/2011/06/windownexttick.html\n            var channel = new MessageChannel();\n            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n            // working message ports the first time a page loads.\n            channel.port1.onmessage = function() {\n                requestTick = requestPortTick;\n                channel.port1.onmessage = flush;\n                flush();\n            };\n            var requestPortTick = function() {\n                // Opera requires us to provide a message payload, regardless of\n                // whether we use it.\n                channel.port2.postMessage(0);\n            };\n            requestTick = function() {\n                setTimeout(flush, 0);\n                requestPortTick();\n            };\n        } else {\n            // old browsers\n            requestTick = function() {\n                setTimeout(flush, 0);\n            };\n        }\n        // runs a task after all other tasks have been run\n        // this is useful for unhandled rejection tracking that needs to happen\n        // after all `then`d tasks have been run.\n        nextTick.runAfter = function(task) {\n            laterQueue.push(task);\n            if (!flushing) {\n                flushing = true;\n                requestTick();\n            }\n        };\n        return nextTick;\n    }();\n    // Attempt to make generics safe in the face of downstream\n    // modifications.\n    // There is no situation where this is necessary.\n    // If you need a security guarantee, these primordials need to be\n    // deeply frozen anyway, and if you don’t need a security guarantee,\n    // this is just plain paranoid.\n    // However, this **might** have the nice side-effect of reducing the size of\n    // the minified code by reducing x.call() to merely x()\n    // See Mark Miller’s explanation of what this does.\n    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n    var call = Function.call;\n    function uncurryThis(f) {\n        return function() {\n            return call.apply(f, arguments);\n        };\n    }\n    // This is equivalent, but slower:\n    // uncurryThis = Function_bind.bind(Function_bind.call);\n    // http://jsperf.com/uncurrythis\n    var array_slice = uncurryThis(Array.prototype.slice);\n    var array_reduce = uncurryThis(Array.prototype.reduce || function(callback, basis) {\n        var index = 0, length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            }while (1);\n        }\n        // reduce\n        for(; index < length; index++){\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    });\n    var array_indexOf = uncurryThis(Array.prototype.indexOf || function(value) {\n        // not a very good shim, but good enough for our one use of it\n        for(var i = 0; i < this.length; i++){\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    });\n    var array_map = uncurryThis(Array.prototype.map || function(callback, thisp) {\n        var self1 = this;\n        var collect = [];\n        array_reduce(self1, function(undefined1, value, index) {\n            collect.push(callback.call(thisp, value, index, self1));\n        }, void 0);\n        return collect;\n    });\n    var object_create = Object.create || function(prototype) {\n        function Type() {}\n        Type.prototype = prototype;\n        return new Type();\n    };\n    var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {\n        obj[prop] = descriptor.value;\n        return obj;\n    };\n    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n    var object_keys = Object.keys || function(object) {\n        var keys = [];\n        for(var key in object){\n            if (object_hasOwnProperty(object, key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    var object_toString = uncurryThis(Object.prototype.toString);\n    function isObject(value) {\n        return value === Object(value);\n    }\n    // generator related shims\n    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n    function isStopIteration(exception) {\n        return object_toString(exception) === \"[object StopIteration]\" || exception instanceof QReturnValue;\n    }\n    // FIXME: Remove this helper and Q.return once ES6 generators are in\n    // SpiderMonkey.\n    var QReturnValue;\n    if (typeof ReturnValue !== \"undefined\") {\n        QReturnValue = ReturnValue;\n    } else {\n        QReturnValue = function(value) {\n            this.value = value;\n        };\n    }\n    // long stack traces\n    var STACK_JUMP_SEPARATOR = \"From previous event:\";\n    function makeStackTraceLong(error, promise) {\n        // If possible, transform the error stack trace by removing Node and Q\n        // cruft, then concatenating with the stack trace of `promise`. See #57.\n        if (hasStacks && promise.stack && typeof error === \"object\" && error !== null && error.stack) {\n            var stacks = [];\n            for(var p = promise; !!p; p = p.source){\n                if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n                    object_defineProperty(error, \"__minimumStackCounter__\", {\n                        value: p.stackCounter,\n                        configurable: true\n                    });\n                    stacks.unshift(p.stack);\n                }\n            }\n            stacks.unshift(error.stack);\n            var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n            var stack = filterStackString(concatedStacks);\n            object_defineProperty(error, \"stack\", {\n                value: stack,\n                configurable: true\n            });\n        }\n    }\n    function filterStackString(stackString) {\n        var lines = stackString.split(\"\\n\");\n        var desiredLines = [];\n        for(var i = 0; i < lines.length; ++i){\n            var line = lines[i];\n            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n                desiredLines.push(line);\n            }\n        }\n        return desiredLines.join(\"\\n\");\n    }\n    function isNodeFrame(stackLine) {\n        return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n    }\n    function getFileNameAndLineNumber(stackLine) {\n        // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n        // In IE10 function name can have spaces (\"Anonymous function\") O_o\n        var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n        if (attempt1) {\n            return [\n                attempt1[1],\n                Number(attempt1[2])\n            ];\n        }\n        // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n        var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n        if (attempt2) {\n            return [\n                attempt2[1],\n                Number(attempt2[2])\n            ];\n        }\n        // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n        var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n        if (attempt3) {\n            return [\n                attempt3[1],\n                Number(attempt3[2])\n            ];\n        }\n    }\n    function isInternalFrame(stackLine) {\n        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n        if (!fileNameAndLineNumber) {\n            return false;\n        }\n        var fileName = fileNameAndLineNumber[0];\n        var lineNumber = fileNameAndLineNumber[1];\n        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;\n    }\n    // discover own file name and line number range for filtering stack\n    // traces\n    function captureLine() {\n        if (!hasStacks) {\n            return;\n        }\n        try {\n            throw new Error();\n        } catch (e) {\n            var lines = e.stack.split(\"\\n\");\n            var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n            if (!fileNameAndLineNumber) {\n                return;\n            }\n            qFileName = fileNameAndLineNumber[0];\n            return fileNameAndLineNumber[1];\n        }\n    }\n    function deprecate(callback, name, alternative) {\n        return function() {\n            if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n                console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n            }\n            return callback.apply(callback, arguments);\n        };\n    }\n    // end of shims\n    // beginning of real work\n    /**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */ function Q(value) {\n        // If the object is already a Promise, return it directly.  This enables\n        // the resolve function to both be used to created references from objects,\n        // but to tolerably coerce non-promises to promises.\n        if (value instanceof Promise) {\n            return value;\n        }\n        // assimilate thenables\n        if (isPromiseAlike(value)) {\n            return coerce(value);\n        } else {\n            return fulfill(value);\n        }\n    }\n    Q.resolve = Q;\n    /**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */ Q.nextTick = nextTick;\n    /**\n * Controls whether or not long stack traces will be on\n */ Q.longStackSupport = false;\n    /**\n * The counter is used to determine the stopping point for building\n * long stack traces. In makeStackTraceLong we walk backwards through\n * the linked list of promises, only stacks which were created before\n * the rejection are concatenated.\n */ var longStackCounter = 1;\n    // enable long stacks if Q_DEBUG is set\n    if (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n        Q.longStackSupport = true;\n    }\n    /**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */ Q.defer = defer;\n    function defer() {\n        // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n        // been resolved.  If it is \"undefined\", it has been resolved.  Each\n        // element of the messages array is itself an array of complete arguments to\n        // forward to the resolved promise.  We coerce the resolution value to a\n        // promise using the `resolve` function because it handles both fully\n        // non-thenable values and other thenables gracefully.\n        var messages = [], progressListeners = [], resolvedPromise;\n        var deferred = object_create(defer.prototype);\n        var promise = object_create(Promise.prototype);\n        promise.promiseDispatch = function(resolve, op, operands) {\n            var args = array_slice(arguments);\n            if (messages) {\n                messages.push(args);\n                if (op === \"when\" && operands[1]) {\n                    progressListeners.push(operands[1]);\n                }\n            } else {\n                Q.nextTick(function() {\n                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n                });\n            }\n        };\n        // XXX deprecated\n        promise.valueOf = function() {\n            if (messages) {\n                return promise;\n            }\n            var nearerValue = nearer(resolvedPromise);\n            if (isPromise(nearerValue)) {\n                resolvedPromise = nearerValue; // shorten chain\n            }\n            return nearerValue;\n        };\n        promise.inspect = function() {\n            if (!resolvedPromise) {\n                return {\n                    state: \"pending\"\n                };\n            }\n            return resolvedPromise.inspect();\n        };\n        if (Q.longStackSupport && hasStacks) {\n            try {\n                throw new Error();\n            } catch (e) {\n                // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n                // accessor around; that causes memory leaks as per GH-111. Just\n                // reify the stack trace as a string ASAP.\n                //\n                // At the same time, cut off the first line; it's always just\n                // \"[object Promise]\\n\", as per the `toString`.\n                promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n                promise.stackCounter = longStackCounter++;\n            }\n        }\n        // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n        // consolidating them into `become`, since otherwise we'd create new\n        // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n        function become(newPromise) {\n            resolvedPromise = newPromise;\n            if (Q.longStackSupport && hasStacks) {\n                // Only hold a reference to the new promise if long stacks\n                // are enabled to reduce memory usage\n                promise.source = newPromise;\n            }\n            array_reduce(messages, function(undefined1, message) {\n                Q.nextTick(function() {\n                    newPromise.promiseDispatch.apply(newPromise, message);\n                });\n            }, void 0);\n            messages = void 0;\n            progressListeners = void 0;\n        }\n        deferred.promise = promise;\n        deferred.resolve = function(value) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(Q(value));\n        };\n        deferred.fulfill = function(value) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(fulfill(value));\n        };\n        deferred.reject = function(reason) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(reject(reason));\n        };\n        deferred.notify = function(progress) {\n            if (resolvedPromise) {\n                return;\n            }\n            array_reduce(progressListeners, function(undefined1, progressListener) {\n                Q.nextTick(function() {\n                    progressListener(progress);\n                });\n            }, void 0);\n        };\n        return deferred;\n    }\n    /**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */ defer.prototype.makeNodeResolver = function() {\n        var self1 = this;\n        return function(error, value) {\n            if (error) {\n                self1.reject(error);\n            } else if (arguments.length > 2) {\n                self1.resolve(array_slice(arguments, 1));\n            } else {\n                self1.resolve(value);\n            }\n        };\n    };\n    /**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */ Q.Promise = promise; // ES6\n    Q.promise = promise;\n    function promise(resolver) {\n        if (typeof resolver !== \"function\") {\n            throw new TypeError(\"resolver must be a function.\");\n        }\n        var deferred = defer();\n        try {\n            resolver(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (reason) {\n            deferred.reject(reason);\n        }\n        return deferred.promise;\n    }\n    promise.race = race; // ES6\n    promise.all = all; // ES6\n    promise.reject = reject; // ES6\n    promise.resolve = Q; // ES6\n    // XXX experimental.  This method is a way to denote that a local value is\n    // serializable and should be immediately dispatched to a remote upon request,\n    // instead of passing a reference.\n    Q.passByCopy = function(object) {\n        //freeze(object);\n        //passByCopies.set(object, true);\n        return object;\n    };\n    Promise.prototype.passByCopy = function() {\n        //freeze(object);\n        //passByCopies.set(object, true);\n        return this;\n    };\n    /**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */ Q.join = function(x, y) {\n        return Q(x).join(y);\n    };\n    Promise.prototype.join = function(that) {\n        return Q([\n            this,\n            that\n        ]).spread(function(x, y) {\n            if (x === y) {\n                // TODO: \"===\" should be Object.is or equiv\n                return x;\n            } else {\n                throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n            }\n        });\n    };\n    /**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */ Q.race = race;\n    function race(answerPs) {\n        return promise(function(resolve, reject) {\n            // Switch to this once we can assume at least ES5\n            // answerPs.forEach(function (answerP) {\n            //     Q(answerP).then(resolve, reject);\n            // });\n            // Use this in the meantime\n            for(var i = 0, len = answerPs.length; i < len; i++){\n                Q(answerPs[i]).then(resolve, reject);\n            }\n        });\n    }\n    Promise.prototype.race = function() {\n        return this.then(Q.race);\n    };\n    /**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */ Q.makePromise = Promise;\n    function Promise(descriptor, fallback, inspect) {\n        if (fallback === void 0) {\n            fallback = function(op) {\n                return reject(new Error(\"Promise does not support operation: \" + op));\n            };\n        }\n        if (inspect === void 0) {\n            inspect = function() {\n                return {\n                    state: \"unknown\"\n                };\n            };\n        }\n        var promise = object_create(Promise.prototype);\n        promise.promiseDispatch = function(resolve, op, args) {\n            var result;\n            try {\n                if (descriptor[op]) {\n                    result = descriptor[op].apply(promise, args);\n                } else {\n                    result = fallback.call(promise, op, args);\n                }\n            } catch (exception) {\n                result = reject(exception);\n            }\n            if (resolve) {\n                resolve(result);\n            }\n        };\n        promise.inspect = inspect;\n        // XXX deprecated `valueOf` and `exception` support\n        if (inspect) {\n            var inspected = inspect();\n            if (inspected.state === \"rejected\") {\n                promise.exception = inspected.reason;\n            }\n            promise.valueOf = function() {\n                var inspected = inspect();\n                if (inspected.state === \"pending\" || inspected.state === \"rejected\") {\n                    return promise;\n                }\n                return inspected.value;\n            };\n        }\n        return promise;\n    }\n    Promise.prototype.toString = function() {\n        return \"[object Promise]\";\n    };\n    Promise.prototype.then = function(fulfilled, rejected, progressed) {\n        var self1 = this;\n        var deferred = defer();\n        var done = false; // ensure the untrusted promise makes at most a\n        // single call to one of the callbacks\n        function _fulfilled(value) {\n            try {\n                return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n            } catch (exception) {\n                return reject(exception);\n            }\n        }\n        function _rejected(exception) {\n            if (typeof rejected === \"function\") {\n                makeStackTraceLong(exception, self1);\n                try {\n                    return rejected(exception);\n                } catch (newException) {\n                    return reject(newException);\n                }\n            }\n            return reject(exception);\n        }\n        function _progressed(value) {\n            return typeof progressed === \"function\" ? progressed(value) : value;\n        }\n        Q.nextTick(function() {\n            self1.promiseDispatch(function(value) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                deferred.resolve(_fulfilled(value));\n            }, \"when\", [\n                function(exception) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    deferred.resolve(_rejected(exception));\n                }\n            ]);\n        });\n        // Progress propagator need to be attached in the current tick.\n        self1.promiseDispatch(void 0, \"when\", [\n            void 0,\n            function(value) {\n                var newValue;\n                var threw = false;\n                try {\n                    newValue = _progressed(value);\n                } catch (e) {\n                    threw = true;\n                    if (Q.onerror) {\n                        Q.onerror(e);\n                    } else {\n                        throw e;\n                    }\n                }\n                if (!threw) {\n                    deferred.notify(newValue);\n                }\n            }\n        ]);\n        return deferred.promise;\n    };\n    Q.tap = function(promise, callback) {\n        return Q(promise).tap(callback);\n    };\n    /**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */ Promise.prototype.tap = function(callback) {\n        callback = Q(callback);\n        return this.then(function(value) {\n            return callback.fcall(value).thenResolve(value);\n        });\n    };\n    /**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */ Q.when = when;\n    function when(value, fulfilled, rejected, progressed) {\n        return Q(value).then(fulfilled, rejected, progressed);\n    }\n    Promise.prototype.thenResolve = function(value) {\n        return this.then(function() {\n            return value;\n        });\n    };\n    Q.thenResolve = function(promise, value) {\n        return Q(promise).thenResolve(value);\n    };\n    Promise.prototype.thenReject = function(reason) {\n        return this.then(function() {\n            throw reason;\n        });\n    };\n    Q.thenReject = function(promise, reason) {\n        return Q(promise).thenReject(reason);\n    };\n    /**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If it’s a fulfilled promise, the fulfillment value is nearer.\n * If it’s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */ // XXX should we re-do this?\n    Q.nearer = nearer;\n    function nearer(value) {\n        if (isPromise(value)) {\n            var inspected = value.inspect();\n            if (inspected.state === \"fulfilled\") {\n                return inspected.value;\n            }\n        }\n        return value;\n    }\n    /**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */ Q.isPromise = isPromise;\n    function isPromise(object) {\n        return object instanceof Promise;\n    }\n    Q.isPromiseAlike = isPromiseAlike;\n    function isPromiseAlike(object) {\n        return isObject(object) && typeof object.then === \"function\";\n    }\n    /**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */ Q.isPending = isPending;\n    function isPending(object) {\n        return isPromise(object) && object.inspect().state === \"pending\";\n    }\n    Promise.prototype.isPending = function() {\n        return this.inspect().state === \"pending\";\n    };\n    /**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */ Q.isFulfilled = isFulfilled;\n    function isFulfilled(object) {\n        return !isPromise(object) || object.inspect().state === \"fulfilled\";\n    }\n    Promise.prototype.isFulfilled = function() {\n        return this.inspect().state === \"fulfilled\";\n    };\n    /**\n * @returns whether the given object is a rejected promise.\n */ Q.isRejected = isRejected;\n    function isRejected(object) {\n        return isPromise(object) && object.inspect().state === \"rejected\";\n    }\n    Promise.prototype.isRejected = function() {\n        return this.inspect().state === \"rejected\";\n    };\n    //// BEGIN UNHANDLED REJECTION TRACKING\n    // This promise library consumes exceptions thrown in handlers so they can be\n    // handled by a subsequent promise.  The exceptions get added to this array when\n    // they are created, and removed when they are handled.  Note that in ES6 or\n    // shimmed environments, this would naturally be a `Set`.\n    var unhandledReasons = [];\n    var unhandledRejections = [];\n    var reportedUnhandledRejections = [];\n    var trackUnhandledRejections = true;\n    function resetUnhandledRejections() {\n        unhandledReasons.length = 0;\n        unhandledRejections.length = 0;\n        if (!trackUnhandledRejections) {\n            trackUnhandledRejections = true;\n        }\n    }\n    function trackRejection(promise, reason) {\n        if (!trackUnhandledRejections) {\n            return;\n        }\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function() {\n                if (array_indexOf(unhandledRejections, promise) !== -1) {\n                    process.emit(\"unhandledRejection\", reason, promise);\n                    reportedUnhandledRejections.push(promise);\n                }\n            });\n        }\n        unhandledRejections.push(promise);\n        if (reason && typeof reason.stack !== \"undefined\") {\n            unhandledReasons.push(reason.stack);\n        } else {\n            unhandledReasons.push(\"(no stack) \" + reason);\n        }\n    }\n    function untrackRejection(promise) {\n        if (!trackUnhandledRejections) {\n            return;\n        }\n        var at = array_indexOf(unhandledRejections, promise);\n        if (at !== -1) {\n            if (typeof process === \"object\" && typeof process.emit === \"function\") {\n                Q.nextTick.runAfter(function() {\n                    var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                    if (atReport !== -1) {\n                        process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                        reportedUnhandledRejections.splice(atReport, 1);\n                    }\n                });\n            }\n            unhandledRejections.splice(at, 1);\n            unhandledReasons.splice(at, 1);\n        }\n    }\n    Q.resetUnhandledRejections = resetUnhandledRejections;\n    Q.getUnhandledReasons = function() {\n        // Make a copy so that consumers can't interfere with our internal state.\n        return unhandledReasons.slice();\n    };\n    Q.stopUnhandledRejectionTracking = function() {\n        resetUnhandledRejections();\n        trackUnhandledRejections = false;\n    };\n    resetUnhandledRejections();\n    //// END UNHANDLED REJECTION TRACKING\n    /**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */ Q.reject = reject;\n    function reject(reason) {\n        var rejection = Promise({\n            \"when\": function(rejected) {\n                // note that the error has been handled\n                if (rejected) {\n                    untrackRejection(this);\n                }\n                return rejected ? rejected(reason) : this;\n            }\n        }, function fallback() {\n            return this;\n        }, function inspect() {\n            return {\n                state: \"rejected\",\n                reason: reason\n            };\n        });\n        // Note that the reason has not been handled.\n        trackRejection(rejection, reason);\n        return rejection;\n    }\n    /**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */ Q.fulfill = fulfill;\n    function fulfill(value) {\n        return Promise({\n            \"when\": function() {\n                return value;\n            },\n            \"get\": function(name) {\n                return value[name];\n            },\n            \"set\": function(name, rhs) {\n                value[name] = rhs;\n            },\n            \"delete\": function(name) {\n                delete value[name];\n            },\n            \"post\": function(name, args) {\n                // Mark Miller proposes that post with no name should apply a\n                // promised function.\n                if (name === null || name === void 0) {\n                    return value.apply(void 0, args);\n                } else {\n                    return value[name].apply(value, args);\n                }\n            },\n            \"apply\": function(thisp, args) {\n                return value.apply(thisp, args);\n            },\n            \"keys\": function() {\n                return object_keys(value);\n            }\n        }, void 0, function inspect() {\n            return {\n                state: \"fulfilled\",\n                value: value\n            };\n        });\n    }\n    /**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */ function coerce(promise) {\n        var deferred = defer();\n        Q.nextTick(function() {\n            try {\n                promise.then(deferred.resolve, deferred.reject, deferred.notify);\n            } catch (exception) {\n                deferred.reject(exception);\n            }\n        });\n        return deferred.promise;\n    }\n    /**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */ Q.master = master;\n    function master(object) {\n        return Promise({\n            \"isDef\": function() {}\n        }, function fallback(op, args) {\n            return dispatch(object, op, args);\n        }, function() {\n            return Q(object).inspect();\n        });\n    }\n    /**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */ Q.spread = spread;\n    function spread(value, fulfilled, rejected) {\n        return Q(value).spread(fulfilled, rejected);\n    }\n    Promise.prototype.spread = function(fulfilled, rejected) {\n        return this.all().then(function(array) {\n            return fulfilled.apply(void 0, array);\n        }, rejected);\n    };\n    /**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */ Q.async = async;\n    function async(makeGenerator) {\n        return function() {\n            // when verb is \"send\", arg is a value\n            // when verb is \"throw\", arg is an exception\n            function continuer(verb, arg) {\n                var result;\n                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n                // engine that has a deployed base of browsers that support generators.\n                // However, SM's generators use the Python-inspired semantics of\n                // outdated ES6 drafts.  We would like to support ES6, but we'd also\n                // like to make it possible to use generators in deployed browsers, so\n                // we also support Python-style generators.  At some point we can remove\n                // this block.\n                if (typeof StopIteration === \"undefined\") {\n                    // ES6 Generators\n                    try {\n                        result = generator[verb](arg);\n                    } catch (exception) {\n                        return reject(exception);\n                    }\n                    if (result.done) {\n                        return Q(result.value);\n                    } else {\n                        return when(result.value, callback, errback);\n                    }\n                } else {\n                    // SpiderMonkey Generators\n                    // FIXME: Remove this case when SM does ES6 generators.\n                    try {\n                        result = generator[verb](arg);\n                    } catch (exception) {\n                        if (isStopIteration(exception)) {\n                            return Q(exception.value);\n                        } else {\n                            return reject(exception);\n                        }\n                    }\n                    return when(result, callback, errback);\n                }\n            }\n            var generator = makeGenerator.apply(this, arguments);\n            var callback = continuer.bind(continuer, \"next\");\n            var errback = continuer.bind(continuer, \"throw\");\n            return callback();\n        };\n    }\n    /**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */ Q.spawn = spawn;\n    function spawn(makeGenerator) {\n        Q.done(Q.async(makeGenerator)());\n    }\n    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n    /**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */ Q[\"return\"] = _return;\n    function _return(value) {\n        throw new QReturnValue(value);\n    }\n    /**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */ Q.promised = promised;\n    function promised(callback) {\n        return function() {\n            return spread([\n                this,\n                all(arguments)\n            ], function(self1, args) {\n                return callback.apply(self1, args);\n            });\n        };\n    }\n    /**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */ Q.dispatch = dispatch;\n    function dispatch(object, op, args) {\n        return Q(object).dispatch(op, args);\n    }\n    Promise.prototype.dispatch = function(op, args) {\n        var self1 = this;\n        var deferred = defer();\n        Q.nextTick(function() {\n            self1.promiseDispatch(deferred.resolve, op, args);\n        });\n        return deferred.promise;\n    };\n    /**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */ Q.get = function(object, key) {\n        return Q(object).dispatch(\"get\", [\n            key\n        ]);\n    };\n    Promise.prototype.get = function(key) {\n        return this.dispatch(\"get\", [\n            key\n        ]);\n    };\n    /**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */ Q.set = function(object, key, value) {\n        return Q(object).dispatch(\"set\", [\n            key,\n            value\n        ]);\n    };\n    Promise.prototype.set = function(key, value) {\n        return this.dispatch(\"set\", [\n            key,\n            value\n        ]);\n    };\n    /**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */ Q.del = Q[\"delete\"] = function(object, key) {\n        return Q(object).dispatch(\"delete\", [\n            key\n        ]);\n    };\n    Promise.prototype.del = Promise.prototype[\"delete\"] = function(key) {\n        return this.dispatch(\"delete\", [\n            key\n        ]);\n    };\n    /**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */ // bound locally because it is used by other methods\n    Q.mapply = Q.post = function(object, name, args) {\n        return Q(object).dispatch(\"post\", [\n            name,\n            args\n        ]);\n    };\n    Promise.prototype.mapply = Promise.prototype.post = function(name, args) {\n        return this.dispatch(\"post\", [\n            name,\n            args\n        ]);\n    };\n    /**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */ Q.send = Q.mcall = Q.invoke = function(object, name /*...args*/ ) {\n        return Q(object).dispatch(\"post\", [\n            name,\n            array_slice(arguments, 2)\n        ]);\n    };\n    Promise.prototype.send = Promise.prototype.mcall = Promise.prototype.invoke = function(name /*...args*/ ) {\n        return this.dispatch(\"post\", [\n            name,\n            array_slice(arguments, 1)\n        ]);\n    };\n    /**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */ Q.fapply = function(object, args) {\n        return Q(object).dispatch(\"apply\", [\n            void 0,\n            args\n        ]);\n    };\n    Promise.prototype.fapply = function(args) {\n        return this.dispatch(\"apply\", [\n            void 0,\n            args\n        ]);\n    };\n    /**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */ Q[\"try\"] = Q.fcall = function(object /* ...args*/ ) {\n        return Q(object).dispatch(\"apply\", [\n            void 0,\n            array_slice(arguments, 1)\n        ]);\n    };\n    Promise.prototype.fcall = function() {\n        return this.dispatch(\"apply\", [\n            void 0,\n            array_slice(arguments)\n        ]);\n    };\n    /**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */ Q.fbind = function(object /*...args*/ ) {\n        var promise = Q(object);\n        var args = array_slice(arguments, 1);\n        return function fbound() {\n            return promise.dispatch(\"apply\", [\n                this,\n                args.concat(array_slice(arguments))\n            ]);\n        };\n    };\n    Promise.prototype.fbind = function() {\n        var promise = this;\n        var args = array_slice(arguments);\n        return function fbound() {\n            return promise.dispatch(\"apply\", [\n                this,\n                args.concat(array_slice(arguments))\n            ]);\n        };\n    };\n    /**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */ Q.keys = function(object) {\n        return Q(object).dispatch(\"keys\", []);\n    };\n    Promise.prototype.keys = function() {\n        return this.dispatch(\"keys\", []);\n    };\n    /**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */ // By Mark Miller\n    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n    Q.all = all;\n    function all(promises) {\n        return when(promises, function(promises) {\n            var pendingCount = 0;\n            var deferred = defer();\n            array_reduce(promises, function(undefined1, promise, index) {\n                var snapshot;\n                if (isPromise(promise) && (snapshot = promise.inspect()).state === \"fulfilled\") {\n                    promises[index] = snapshot.value;\n                } else {\n                    ++pendingCount;\n                    when(promise, function(value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    }, deferred.reject, function(progress) {\n                        deferred.notify({\n                            index: index,\n                            value: progress\n                        });\n                    });\n                }\n            }, void 0);\n            if (pendingCount === 0) {\n                deferred.resolve(promises);\n            }\n            return deferred.promise;\n        });\n    }\n    Promise.prototype.all = function() {\n        return all(this);\n    };\n    /**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */ Q.any = any;\n    function any(promises) {\n        if (promises.length === 0) {\n            return Q.resolve();\n        }\n        var deferred = Q.defer();\n        var pendingCount = 0;\n        array_reduce(promises, function(prev, current, index) {\n            var promise = promises[index];\n            pendingCount++;\n            when(promise, onFulfilled, onRejected, onProgress);\n            function onFulfilled(result) {\n                deferred.resolve(result);\n            }\n            function onRejected(err) {\n                pendingCount--;\n                if (pendingCount === 0) {\n                    var rejection = err || new Error(\"\" + err);\n                    rejection.message = \"Q can't get fulfillment value from any promise, all \" + \"promises were rejected. Last error message: \" + rejection.message;\n                    deferred.reject(rejection);\n                }\n            }\n            function onProgress(progress) {\n                deferred.notify({\n                    index: index,\n                    value: progress\n                });\n            }\n        }, undefined);\n        return deferred.promise;\n    }\n    Promise.prototype.any = function() {\n        return any(this);\n    };\n    /**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */ Q.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n    function allResolved(promises) {\n        return when(promises, function(promises) {\n            promises = array_map(promises, Q);\n            return when(all(array_map(promises, function(promise) {\n                return when(promise, noop, noop);\n            })), function() {\n                return promises;\n            });\n        });\n    }\n    Promise.prototype.allResolved = function() {\n        return allResolved(this);\n    };\n    /**\n * @see Promise#allSettled\n */ Q.allSettled = allSettled;\n    function allSettled(promises) {\n        return Q(promises).allSettled();\n    }\n    /**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */ Promise.prototype.allSettled = function() {\n        return this.then(function(promises) {\n            return all(array_map(promises, function(promise) {\n                promise = Q(promise);\n                function regardless() {\n                    return promise.inspect();\n                }\n                return promise.then(regardless, regardless);\n            }));\n        });\n    };\n    /**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */ Q.fail = Q[\"catch\"] = function(object, rejected) {\n        return Q(object).then(void 0, rejected);\n    };\n    Promise.prototype.fail = Promise.prototype[\"catch\"] = function(rejected) {\n        return this.then(void 0, rejected);\n    };\n    /**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */ Q.progress = progress;\n    function progress(object, progressed) {\n        return Q(object).then(void 0, void 0, progressed);\n    }\n    Promise.prototype.progress = function(progressed) {\n        return this.then(void 0, void 0, progressed);\n    };\n    /**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */ Q.fin = Q[\"finally\"] = function(object, callback) {\n        return Q(object)[\"finally\"](callback);\n    };\n    Promise.prototype.fin = Promise.prototype[\"finally\"] = function(callback) {\n        if (!callback || typeof callback.apply !== \"function\") {\n            throw new Error(\"Q can't apply finally callback\");\n        }\n        callback = Q(callback);\n        return this.then(function(value) {\n            return callback.fcall().then(function() {\n                return value;\n            });\n        }, function(reason) {\n            // TODO attempt to recycle the rejection with \"this\".\n            return callback.fcall().then(function() {\n                throw reason;\n            });\n        });\n    };\n    /**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */ Q.done = function(object, fulfilled, rejected, progress) {\n        return Q(object).done(fulfilled, rejected, progress);\n    };\n    Promise.prototype.done = function(fulfilled, rejected, progress) {\n        var onUnhandledError = function(error) {\n            // forward to a future turn so that ``when``\n            // does not catch it and turn it into a rejection.\n            Q.nextTick(function() {\n                makeStackTraceLong(error, promise);\n                if (Q.onerror) {\n                    Q.onerror(error);\n                } else {\n                    throw error;\n                }\n            });\n        };\n        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;\n        if (typeof process === \"object\" && process && process.domain) {\n            onUnhandledError = process.domain.bind(onUnhandledError);\n        }\n        promise.then(void 0, onUnhandledError);\n    };\n    /**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */ Q.timeout = function(object, ms, error) {\n        return Q(object).timeout(ms, error);\n    };\n    Promise.prototype.timeout = function(ms, error) {\n        var deferred = defer();\n        var timeoutId = setTimeout(function() {\n            if (!error || \"string\" === typeof error) {\n                error = new Error(error || \"Timed out after \" + ms + \" ms\");\n                error.code = \"ETIMEDOUT\";\n            }\n            deferred.reject(error);\n        }, ms);\n        this.then(function(value) {\n            clearTimeout(timeoutId);\n            deferred.resolve(value);\n        }, function(exception) {\n            clearTimeout(timeoutId);\n            deferred.reject(exception);\n        }, deferred.notify);\n        return deferred.promise;\n    };\n    /**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */ Q.delay = function(object, timeout) {\n        if (timeout === void 0) {\n            timeout = object;\n            object = void 0;\n        }\n        return Q(object).delay(timeout);\n    };\n    Promise.prototype.delay = function(timeout) {\n        return this.then(function(value) {\n            var deferred = defer();\n            setTimeout(function() {\n                deferred.resolve(value);\n            }, timeout);\n            return deferred.promise;\n        });\n    };\n    /**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */ Q.nfapply = function(callback, args) {\n        return Q(callback).nfapply(args);\n    };\n    Promise.prototype.nfapply = function(args) {\n        var deferred = defer();\n        var nodeArgs = array_slice(args);\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */ Q.nfcall = function(callback /*...args*/ ) {\n        var args = array_slice(arguments, 1);\n        return Q(callback).nfapply(args);\n    };\n    Promise.prototype.nfcall = function() {\n        var nodeArgs = array_slice(arguments);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */ Q.nfbind = Q.denodeify = function(callback /*...args*/ ) {\n        if (callback === undefined) {\n            throw new Error(\"Q can't wrap an undefined function\");\n        }\n        var baseArgs = array_slice(arguments, 1);\n        return function() {\n            var nodeArgs = baseArgs.concat(array_slice(arguments));\n            var deferred = defer();\n            nodeArgs.push(deferred.makeNodeResolver());\n            Q(callback).fapply(nodeArgs).fail(deferred.reject);\n            return deferred.promise;\n        };\n    };\n    Promise.prototype.nfbind = Promise.prototype.denodeify = function() {\n        var args = array_slice(arguments);\n        args.unshift(this);\n        return Q.denodeify.apply(void 0, args);\n    };\n    Q.nbind = function(callback, thisp /*...args*/ ) {\n        var baseArgs = array_slice(arguments, 2);\n        return function() {\n            var nodeArgs = baseArgs.concat(array_slice(arguments));\n            var deferred = defer();\n            nodeArgs.push(deferred.makeNodeResolver());\n            function bound() {\n                return callback.apply(thisp, arguments);\n            }\n            Q(bound).fapply(nodeArgs).fail(deferred.reject);\n            return deferred.promise;\n        };\n    };\n    Promise.prototype.nbind = function() {\n        var args = array_slice(arguments, 0);\n        args.unshift(this);\n        return Q.nbind.apply(void 0, args);\n    };\n    /**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */ Q.nmapply = Q.npost = function(object, name, args) {\n        return Q(object).npost(name, args);\n    };\n    Promise.prototype.nmapply = Promise.prototype.npost = function(name, args) {\n        var nodeArgs = array_slice(args || []);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */ Q.nsend = Q.nmcall = Q.ninvoke = function(object, name /*...args*/ ) {\n        var nodeArgs = array_slice(arguments, 2);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(object).dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    Promise.prototype.nsend = Promise.prototype.nmcall = Promise.prototype.ninvoke = function(name /*...args*/ ) {\n        var nodeArgs = array_slice(arguments, 1);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */ Q.nodeify = nodeify;\n    function nodeify(object, nodeback) {\n        return Q(object).nodeify(nodeback);\n    }\n    Promise.prototype.nodeify = function(nodeback) {\n        if (nodeback) {\n            this.then(function(value) {\n                Q.nextTick(function() {\n                    nodeback(null, value);\n                });\n            }, function(error) {\n                Q.nextTick(function() {\n                    nodeback(error);\n                });\n            });\n        } else {\n            return this;\n        }\n    };\n    Q.noConflict = function() {\n        throw new Error(\"Q.noConflict only works when Q is used as a global\");\n    };\n    // All code before this point will be filtered from stack traces.\n    var qEndingLine = captureLine();\n    return Q;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFFBQVEsQ0FBQyxRQUFRO1lBQUN4RjtZQUFNd0k7U0FBUyxFQUFFVixJQUFJLENBQUM3RyxTQUFTZSxNQUFNO1FBQzVELE9BQU9mLFNBQVNoRCxPQUFPO0lBQzNCO0lBRUE7Ozs7Ozs7OztDQVNDLEdBQ0R6RixFQUFFNFEsT0FBTyxHQUFHQTtJQUNaLFNBQVNBLFFBQVE5TCxNQUFNLEVBQUUrTCxRQUFRO1FBQzdCLE9BQU83USxFQUFFOEUsUUFBUThMLE9BQU8sQ0FBQ0M7SUFDN0I7SUFFQWpKLFFBQVE1RSxTQUFTLENBQUM0TixPQUFPLEdBQUcsU0FBVUMsUUFBUTtRQUMxQyxJQUFJQSxVQUFVO1lBQ1YsSUFBSSxDQUFDckcsSUFBSSxDQUFDLFNBQVU5RyxLQUFLO2dCQUNyQjFELEVBQUVVLFFBQVEsQ0FBQztvQkFDUG1RLFNBQVMsTUFBTW5OO2dCQUNuQjtZQUNKLEdBQUcsU0FBVThCLEtBQUs7Z0JBQ2R4RixFQUFFVSxRQUFRLENBQUM7b0JBQ1BtUSxTQUFTckw7Z0JBQ2I7WUFDSjtRQUNKLE9BQU87WUFDSCxPQUFPLElBQUk7UUFDZjtJQUNKO0lBRUF4RixFQUFFQyxVQUFVLEdBQUc7UUFDWCxNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFFQSxpRUFBaUU7SUFDakUsSUFBSW1ILGNBQWM5RztJQUVsQixPQUFPUDtBQUVQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW1hZ2luaWZ5Ly4vbm9kZV9tb2R1bGVzL3EvcS5qcz9jZTE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHZpbTp0cz00OnN0cz00OnN3PTQ6XG4vKiFcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE3IEtyaXMgS293YWwgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVRcbiAqIGxpY2Vuc2UgZm91bmQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL2Jsb2IvdjEvTElDRU5TRVxuICpcbiAqIFdpdGggcGFydHMgYnkgVHlsZXIgQ2xvc2VcbiAqIENvcHlyaWdodCAyMDA3LTIwMDkgVHlsZXIgQ2xvc2UgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgWCBsaWNlbnNlIGZvdW5kXG4gKiBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWxcbiAqIEZvcmtlZCBhdCByZWZfc2VuZC5qcyB2ZXJzaW9uOiAyMDA5LTA1LTExXG4gKlxuICogV2l0aCBwYXJ0cyBieSBNYXJrIE1pbGxlclxuICogQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVGhpcyBmaWxlIHdpbGwgZnVuY3Rpb24gcHJvcGVybHkgYXMgYSA8c2NyaXB0PiB0YWcsIG9yIGEgbW9kdWxlXG4gICAgLy8gdXNpbmcgQ29tbW9uSlMgYW5kIE5vZGVKUyBvciBSZXF1aXJlSlMgbW9kdWxlIGZvcm1hdHMuICBJblxuICAgIC8vIENvbW1vbi9Ob2RlL1JlcXVpcmVKUywgdGhlIG1vZHVsZSBleHBvcnRzIHRoZSBRIEFQSSBhbmQgd2hlblxuICAgIC8vIGV4ZWN1dGVkIGFzIGEgc2ltcGxlIDxzY3JpcHQ+LCBpdCBjcmVhdGVzIGEgUSBnbG9iYWwgaW5zdGVhZC5cblxuICAgIC8vIE1vbnRhZ2UgUmVxdWlyZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9vdHN0cmFwKFwicHJvbWlzZVwiLCBkZWZpbml0aW9uKTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBQcmVmZXIgd2luZG93IG92ZXIgc2VsZiBmb3IgYWRkLW9uIHNjcmlwdHMuIFVzZSBzZWxmIGZvclxuICAgICAgICAvLyBub24td2luZG93ZWQgY29udGV4dHMuXG4gICAgICAgIHZhciBnbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogc2VsZjtcblxuICAgICAgICAvLyBHZXQgdGhlIGB3aW5kb3dgIG9iamVjdCwgc2F2ZSB0aGUgcHJldmlvdXMgUSBnbG9iYWxcbiAgICAgICAgLy8gYW5kIGluaXRpYWxpemUgUSBhcyBhIGdsb2JhbC5cbiAgICAgICAgdmFyIHByZXZpb3VzUSA9IGdsb2JhbC5RO1xuICAgICAgICBnbG9iYWwuUSA9IGRlZmluaXRpb24oKTtcblxuICAgICAgICAvLyBBZGQgYSBub0NvbmZsaWN0IGZ1bmN0aW9uIHNvIFEgY2FuIGJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgICAgLy8gZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgZ2xvYmFsLlEubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdsb2JhbC5RID0gcHJldmlvdXNRO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGVudmlyb25tZW50IHdhcyBub3QgYW50aWNpcGF0ZWQgYnkgUS4gUGxlYXNlIGZpbGUgYSBidWcuXCIpO1xuICAgIH1cblxufSkoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoYXNTdGFja3MgPSBmYWxzZTtcbnRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzU3RhY2tzID0gISFlLnN0YWNrO1xufVxuXG4vLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWRcbi8vIGJ5IFEuXG52YXIgcVN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG52YXIgcUZpbGVOYW1lO1xuXG4vLyBzaGltc1xuXG4vLyB1c2VkIGZvciBmYWxsYmFjayBpbiBcImFsbFJlc29sdmVkXCJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cbnZhciBuZXh0VGljayA9KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBsaW5rZWQgbGlzdCBvZiB0YXNrcyAoc2luZ2xlLCB3aXRoIGhlYWQgbm9kZSlcbiAgICB2YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xuICAgIHZhciB0YWlsID0gaGVhZDtcbiAgICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSB2b2lkIDA7XG4gICAgdmFyIGlzTm9kZUpTID0gZmFsc2U7XG4gICAgLy8gcXVldWUgZm9yIGxhdGUgdGFza3MsIHVzZWQgYnkgdW5oYW5kbGVkIHJlamVjdGlvbiB0cmFja2luZ1xuICAgIHZhciBsYXRlclF1ZXVlID0gW107XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgIHZhciB0YXNrLCBkb21haW47XG5cbiAgICAgICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgICAgIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICAgICAgICBoZWFkLnRhc2sgPSB2b2lkIDA7XG4gICAgICAgICAgICBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuU2luZ2xlKHRhc2ssIGRvbWFpbik7XG5cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGF0ZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhc2sgPSBsYXRlclF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgcnVuU2luZ2xlKHRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJ1bnMgYSBzaW5nbGUgZnVuY3Rpb24gaW4gdGhlIGFzeW5jIHF1ZXVlXG4gICAgZnVuY3Rpb24gcnVuU2luZ2xlKHRhc2ssIGRvbWFpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gc3luY2hyb25vdXNseSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluIG5leHQgZXZlbnQgdG8gYXZvaWQgdGljayByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV4dFRpY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB0YWlsID0gdGFpbC5uZXh0ID0ge1xuICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgIGRvbWFpbjogaXNOb2RlSlMgJiYgcHJvY2Vzcy5kb21haW4sXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcHJvY2Vzcy50b1N0cmluZygpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICAgIC8vIEVuc3VyZSBRIGlzIGluIGEgcmVhbCBOb2RlIGVudmlyb25tZW50LCB3aXRoIGEgYHByb2Nlc3MubmV4dFRpY2tgLlxuICAgICAgICAvLyBUbyBzZWUgdGhyb3VnaCBmYWtlIE5vZGUgZW52aXJvbm1lbnRzOlxuICAgICAgICAvLyAqIE1vY2hhIHRlc3QgcnVubmVyIC0gZXhwb3NlcyBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2BcbiAgICAgICAgLy8gKiBCcm93c2VyaWZ5IC0gZXhwb3NlcyBhIGBwcm9jZXNzLm5leFRpY2tgIGZ1bmN0aW9uIHRoYXQgdXNlc1xuICAgICAgICAvLyAgIGBzZXRUaW1lb3V0YC4gSW4gdGhpcyBjYXNlIGBzZXRJbW1lZGlhdGVgIGlzIHByZWZlcnJlZCBiZWNhdXNlXG4gICAgICAgIC8vICAgIGl0IGlzIGZhc3Rlci4gQnJvd3NlcmlmeSdzIGBwcm9jZXNzLnRvU3RyaW5nKClgIHlpZWxkc1xuICAgICAgICAvLyAgIFwiW29iamVjdCBPYmplY3RdXCIsIHdoaWxlIGluIGEgcmVhbCBOb2RlIGVudmlyb25tZW50XG4gICAgICAgIC8vICAgYHByb2Nlc3MudG9TdHJpbmcoKWAgeWllbGRzIFwiW29iamVjdCBwcm9jZXNzXVwiLlxuICAgICAgICBpc05vZGVKUyA9IHRydWU7XG5cbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIEluIElFMTAsIE5vZGUuanMgMC45Kywgb3IgaHR0cHM6Ly9naXRodWIuY29tL05vYmxlSlMvc2V0SW1tZWRpYXRlXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHNldEltbWVkaWF0ZS5iaW5kKHdpbmRvdywgZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAvLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAvLyBBdCBsZWFzdCBTYWZhcmkgVmVyc2lvbiA2LjAuNSAoODUzNi4zMC4xKSBpbnRlcm1pdHRlbnRseSBjYW5ub3QgY3JlYXRlXG4gICAgICAgIC8vIHdvcmtpbmcgbWVzc2FnZSBwb3J0cyB0aGUgZmlyc3QgdGltZSBhIHBhZ2UgbG9hZHMuXG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSByZXF1ZXN0UG9ydFRpY2s7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcXVlc3RQb3J0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9wZXJhIHJlcXVpcmVzIHVzIHRvIHByb3ZpZGUgYSBtZXNzYWdlIHBheWxvYWQsIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgd2UgdXNlIGl0LlxuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgIHJlcXVlc3RQb3J0VGljaygpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHJ1bnMgYSB0YXNrIGFmdGVyIGFsbCBvdGhlciB0YXNrcyBoYXZlIGJlZW4gcnVuXG4gICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmcgdGhhdCBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciBhbGwgYHRoZW5gZCB0YXNrcyBoYXZlIGJlZW4gcnVuLlxuICAgIG5leHRUaWNrLnJ1bkFmdGVyID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgbGF0ZXJRdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV4dFRpY2s7XG59KSgpO1xuXG4vLyBBdHRlbXB0IHRvIG1ha2UgZ2VuZXJpY3Mgc2FmZSBpbiB0aGUgZmFjZSBvZiBkb3duc3RyZWFtXG4vLyBtb2RpZmljYXRpb25zLlxuLy8gVGhlcmUgaXMgbm8gc2l0dWF0aW9uIHdoZXJlIHRoaXMgaXMgbmVjZXNzYXJ5LlxuLy8gSWYgeW91IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsIHRoZXNlIHByaW1vcmRpYWxzIG5lZWQgdG8gYmVcbi8vIGRlZXBseSBmcm96ZW4gYW55d2F5LCBhbmQgaWYgeW91IGRvbuKAmXQgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSxcbi8vIHRoaXMgaXMganVzdCBwbGFpbiBwYXJhbm9pZC5cbi8vIEhvd2V2ZXIsIHRoaXMgKiptaWdodCoqIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemUgb2Zcbi8vIHRoZSBtaW5pZmllZCBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KClcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9kZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG4gICAgb2JqW3Byb3BdID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIGxvbmcgc3RhY2sgdHJhY2VzXG5cbnZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIjtcblxuZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUVxuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYHByb21pc2VgLiBTZWUgIzU3LlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgcHJvbWlzZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2tcbiAgICApIHtcbiAgICAgICAgdmFyIHN0YWNrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwID0gcHJvbWlzZTsgISFwOyBwID0gcC5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChwLnN0YWNrICYmICghZXJyb3IuX19taW5pbXVtU3RhY2tDb3VudGVyX18gfHwgZXJyb3IuX19taW5pbXVtU3RhY2tDb3VudGVyX18gPiBwLnN0YWNrQ291bnRlcikpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RfZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwiX19taW5pbXVtU3RhY2tDb3VudGVyX19cIiwge3ZhbHVlOiBwLnN0YWNrQ291bnRlciwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgc3RhY2tzLnVuc2hpZnQocC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnVuc2hpZnQoZXJyb3Iuc3RhY2spO1xuXG4gICAgICAgIHZhciBjb25jYXRlZFN0YWNrcyA9IHN0YWNrcy5qb2luKFwiXFxuXCIgKyBTVEFDS19KVU1QX1NFUEFSQVRPUiArIFwiXFxuXCIpO1xuICAgICAgICB2YXIgc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgICAgIG9iamVjdF9kZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJzdGFja1wiLCB7dmFsdWU6IHN0YWNrLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlclN0YWNrU3RyaW5nKHN0YWNrU3RyaW5nKSB7XG4gICAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGRlc2lyZWRMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICBpZiAoIWlzSW50ZXJuYWxGcmFtZShsaW5lKSAmJiAhaXNOb2RlRnJhbWUobGluZSkgJiYgbGluZSkge1xuICAgICAgICAgICAgZGVzaXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRMaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVGcmFtZShzdGFja0xpbmUpIHtcbiAgICByZXR1cm4gc3RhY2tMaW5lLmluZGV4T2YoXCIobW9kdWxlLmpzOlwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgc3RhY2tMaW5lLmluZGV4T2YoXCIobm9kZS5qczpcIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKSB7XG4gICAgLy8gTmFtZWQgZnVuY3Rpb25zOiBcImF0IGZ1bmN0aW9uTmFtZSAoZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXIpXCJcbiAgICAvLyBJbiBJRTEwIGZ1bmN0aW9uIG5hbWUgY2FuIGhhdmUgc3BhY2VzIChcIkFub255bW91cyBmdW5jdGlvblwiKSBPX29cbiAgICB2YXIgYXR0ZW1wdDEgPSAvYXQgLisgXFwoKC4rKTooXFxkKyk6KD86XFxkKylcXCkkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQxKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDFbMV0sIE51bWJlcihhdHRlbXB0MVsyXSldO1xuICAgIH1cblxuICAgIC8vIEFub255bW91cyBmdW5jdGlvbnM6IFwiYXQgZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MiA9IC9hdCAoW14gXSspOihcXGQrKTooPzpcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDIpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MlsxXSwgTnVtYmVyKGF0dGVtcHQyWzJdKV07XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCBzdHlsZTogXCJmdW5jdGlvbkBmaWxlbmFtZTpsaW5lTnVtYmVyIG9yIEBmaWxlbmFtZTpsaW5lTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDMgPSAvLipAKC4rKTooXFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQzKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDNbMV0sIE51bWJlcihhdHRlbXB0M1syXSldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnRlcm5hbEZyYW1lKHN0YWNrTGluZSkge1xuICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKTtcblxuICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG5cbiAgICByZXR1cm4gZmlsZU5hbWUgPT09IHFGaWxlTmFtZSAmJlxuICAgICAgICBsaW5lTnVtYmVyID49IHFTdGFydGluZ0xpbmUgJiZcbiAgICAgICAgbGluZU51bWJlciA8PSBxRW5kaW5nTGluZTtcbn1cblxuLy8gZGlzY292ZXIgb3duIGZpbGUgbmFtZSBhbmQgbGluZSBudW1iZXIgcmFuZ2UgZm9yIGZpbHRlcmluZyBzdGFja1xuLy8gdHJhY2VzXG5mdW5jdGlvbiBjYXB0dXJlTGluZSgpIHtcbiAgICBpZiAoIWhhc1N0YWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gbGluZXNbMF0uaW5kZXhPZihcIkBcIikgPiAwID8gbGluZXNbMV0gOiBsaW5lc1syXTtcbiAgICAgICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihmaXJzdExpbmUpO1xuICAgICAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcUZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgICAgICByZXR1cm4gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKGNhbGxiYWNrLCBuYW1lLCBhbHRlcm5hdGl2ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcIiArIGFsdGVybmF0aXZlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpbnN0ZWFkLlwiLCBuZXcgRXJyb3IoXCJcIikuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShjYWxsYmFjaywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vLyBlbmQgb2Ygc2hpbXNcbi8vIGJlZ2lubmluZyBvZiByZWFsIHdvcmtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZSwgcGFzc2VzIHByb21pc2VzIHRocm91Z2gsIG9yXG4gKiBjb2VyY2VzIHByb21pc2VzIGZyb20gZGlmZmVyZW50IHN5c3RlbXMuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZSBvciBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIFEodmFsdWUpIHtcbiAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIGFscmVhZHkgYSBQcm9taXNlLCByZXR1cm4gaXQgZGlyZWN0bHkuICBUaGlzIGVuYWJsZXNcbiAgICAvLyB0aGUgcmVzb2x2ZSBmdW5jdGlvbiB0byBib3RoIGJlIHVzZWQgdG8gY3JlYXRlZCByZWZlcmVuY2VzIGZyb20gb2JqZWN0cyxcbiAgICAvLyBidXQgdG8gdG9sZXJhYmx5IGNvZXJjZSBub24tcHJvbWlzZXMgdG8gcHJvbWlzZXMuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gYXNzaW1pbGF0ZSB0aGVuYWJsZXNcbiAgICBpZiAoaXNQcm9taXNlQWxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsKHZhbHVlKTtcbiAgICB9XG59XG5RLnJlc29sdmUgPSBRO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuIG9mIHRoZSBldmVudCBsb29wLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdGFza1xuICovXG5RLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbi8qKlxuICogQ29udHJvbHMgd2hldGhlciBvciBub3QgbG9uZyBzdGFjayB0cmFjZXMgd2lsbCBiZSBvblxuICovXG5RLmxvbmdTdGFja1N1cHBvcnQgPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgY291bnRlciBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc3RvcHBpbmcgcG9pbnQgZm9yIGJ1aWxkaW5nXG4gKiBsb25nIHN0YWNrIHRyYWNlcy4gSW4gbWFrZVN0YWNrVHJhY2VMb25nIHdlIHdhbGsgYmFja3dhcmRzIHRocm91Z2hcbiAqIHRoZSBsaW5rZWQgbGlzdCBvZiBwcm9taXNlcywgb25seSBzdGFja3Mgd2hpY2ggd2VyZSBjcmVhdGVkIGJlZm9yZVxuICogdGhlIHJlamVjdGlvbiBhcmUgY29uY2F0ZW5hdGVkLlxuICovXG52YXIgbG9uZ1N0YWNrQ291bnRlciA9IDE7XG5cbi8vIGVuYWJsZSBsb25nIHN0YWNrcyBpZiBRX0RFQlVHIGlzIHNldFxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuUV9ERUJVRykge1xuICAgIFEubG9uZ1N0YWNrU3VwcG9ydCA9IHRydWU7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHtwcm9taXNlLCByZXNvbHZlLCByZWplY3R9IG9iamVjdC5cbiAqXG4gKiBgcmVzb2x2ZWAgaXMgYSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBhIG1vcmUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZVxuICogcHJvbWlzZS4gVG8gZnVsZmlsbCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGFueSB2YWx1ZSB0aGF0IGlzXG4gKiBub3QgYSB0aGVuYWJsZS4gVG8gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYSByZWplY3RlZFxuICogdGhlbmFibGUsIG9yIGludm9rZSBgcmVqZWN0YCB3aXRoIHRoZSByZWFzb24gZGlyZWN0bHkuIFRvIHJlc29sdmUgdGhlXG4gKiBwcm9taXNlIHRvIGFub3RoZXIgdGhlbmFibGUsIHRodXMgcHV0dGluZyBpdCBpbiB0aGUgc2FtZSBzdGF0ZSwgaW52b2tlXG4gKiBgcmVzb2x2ZWAgd2l0aCB0aGF0IG90aGVyIHRoZW5hYmxlLlxuICovXG5RLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICAvLyBpZiBcIm1lc3NhZ2VzXCIgaXMgYW4gXCJBcnJheVwiLCB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSBwcm9taXNlIGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiByZXNvbHZlZC4gIElmIGl0IGlzIFwidW5kZWZpbmVkXCIsIGl0IGhhcyBiZWVuIHJlc29sdmVkLiAgRWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIG1lc3NhZ2VzIGFycmF5IGlzIGl0c2VsZiBhbiBhcnJheSBvZiBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXNvbHZlZCBwcm9taXNlLiAgV2UgY29lcmNlIHRoZSByZXNvbHV0aW9uIHZhbHVlIHRvIGFcbiAgICAvLyBwcm9taXNlIHVzaW5nIHRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gYmVjYXVzZSBpdCBoYW5kbGVzIGJvdGggZnVsbHlcbiAgICAvLyBub24tdGhlbmFibGUgdmFsdWVzIGFuZCBvdGhlciB0aGVuYWJsZXMgZ3JhY2VmdWxseS5cbiAgICB2YXIgbWVzc2FnZXMgPSBbXSwgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSwgcmVzb2x2ZWRQcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gb2JqZWN0X2NyZWF0ZShkZWZlci5wcm90b3R5cGUpO1xuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgb3BlcmFuZHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goYXJncyk7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwid2hlblwiICYmIG9wZXJhbmRzWzFdKSB7IC8vIHByb2dyZXNzIG9wZXJhbmRcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVycy5wdXNoKG9wZXJhbmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyZXJWYWx1ZSA9IG5lYXJlcihyZXNvbHZlZFByb21pc2UpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKG5lYXJlclZhbHVlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmVhcmVyVmFsdWU7IC8vIHNob3J0ZW4gY2hhaW5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVyVmFsdWU7XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBlbmRpbmdcIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFByb21pc2UuaW5zcGVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvbid0IHRyeSB0byB1c2UgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCBvciB0cmFuc2ZlciB0aGVcbiAgICAgICAgICAgIC8vIGFjY2Vzc29yIGFyb3VuZDsgdGhhdCBjYXVzZXMgbWVtb3J5IGxlYWtzIGFzIHBlciBHSC0xMTEuIEp1c3RcbiAgICAgICAgICAgIC8vIHJlaWZ5IHRoZSBzdGFjayB0cmFjZSBhcyBhIHN0cmluZyBBU0FQLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUsIGN1dCBvZmYgdGhlIGZpcnN0IGxpbmU7IGl0J3MgYWx3YXlzIGp1c3RcbiAgICAgICAgICAgIC8vIFwiW29iamVjdCBQcm9taXNlXVxcblwiLCBhcyBwZXIgdGhlIGB0b1N0cmluZ2AuXG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrQ291bnRlciA9IGxvbmdTdGFja0NvdW50ZXIrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IHdlIGRvIHRoZSBjaGVja3MgZm9yIGByZXNvbHZlZFByb21pc2VgIGluIGVhY2ggbWV0aG9kLCBpbnN0ZWFkIG9mXG4gICAgLy8gY29uc29saWRhdGluZyB0aGVtIGludG8gYGJlY29tZWAsIHNpbmNlIG90aGVyd2lzZSB3ZSdkIGNyZWF0ZSBuZXdcbiAgICAvLyBwcm9taXNlcyB3aXRoIHRoZSBsaW5lcyBgYmVjb21lKHdoYXRldmVyKHZhbHVlKSlgLiBTZWUgZS5nLiBHSC0yNTIuXG5cbiAgICBmdW5jdGlvbiBiZWNvbWUobmV3UHJvbWlzZSkge1xuICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZXdQcm9taXNlO1xuXG4gICAgICAgIGlmIChRLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGhvbGQgYSByZWZlcmVuY2UgdG8gdGhlIG5ldyBwcm9taXNlIGlmIGxvbmcgc3RhY2tzXG4gICAgICAgICAgICAvLyBhcmUgZW5hYmxlZCB0byByZWR1Y2UgbWVtb3J5IHVzYWdlXG4gICAgICAgICAgICBwcm9taXNlLnNvdXJjZSA9IG5ld1Byb21pc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UobWVzc2FnZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5ld1Byb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KG5ld1Byb21pc2UsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG5cbiAgICAgICAgbWVzc2FnZXMgPSB2b2lkIDA7XG4gICAgICAgIHByb2dyZXNzTGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIH1cblxuICAgIGRlZmVycmVkLnByb21pc2UgPSBwcm9taXNlO1xuICAgIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKFEodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgZGVmZXJyZWQuZnVsZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoZnVsZmlsbCh2YWx1ZSkpO1xuICAgIH07XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUocmVqZWN0KHJlYXNvbikpO1xuICAgIH07XG4gICAgZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9ncmVzc0xpc3RlbmVycywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvZ3Jlc3NMaXN0ZW5lcikge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBOb2RlLXN0eWxlIGNhbGxiYWNrIHRoYXQgd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAqIHByb21pc2UuXG4gKiBAcmV0dXJucyBhIG5vZGViYWNrXG4gKi9cbmRlZmVyLnByb3RvdHlwZS5tYWtlTm9kZVJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSByZXNvbHZlciB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vdGhpbmcgYW5kIGFjY2VwdHNcbiAqIHRoZSByZXNvbHZlLCByZWplY3QsIGFuZCBub3RpZnkgZnVuY3Rpb25zIGZvciBhIGRlZmVycmVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgbWF5IGJlIHJlc29sdmVkIHdpdGggdGhlIGdpdmVuIHJlc29sdmUgYW5kIHJlamVjdFxuICogZnVuY3Rpb25zLCBvciByZWplY3RlZCBieSBhIHRocm93biBleGNlcHRpb24gaW4gcmVzb2x2ZXJcbiAqL1xuUS5Qcm9taXNlID0gcHJvbWlzZTsgLy8gRVM2XG5RLnByb21pc2UgPSBwcm9taXNlO1xuZnVuY3Rpb24gcHJvbWlzZShyZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxucHJvbWlzZS5yYWNlID0gcmFjZTsgLy8gRVM2XG5wcm9taXNlLmFsbCA9IGFsbDsgLy8gRVM2XG5wcm9taXNlLnJlamVjdCA9IHJlamVjdDsgLy8gRVM2XG5wcm9taXNlLnJlc29sdmUgPSBROyAvLyBFUzZcblxuLy8gWFhYIGV4cGVyaW1lbnRhbC4gIFRoaXMgbWV0aG9kIGlzIGEgd2F5IHRvIGRlbm90ZSB0aGF0IGEgbG9jYWwgdmFsdWUgaXNcbi8vIHNlcmlhbGl6YWJsZSBhbmQgc2hvdWxkIGJlIGltbWVkaWF0ZWx5IGRpc3BhdGNoZWQgdG8gYSByZW1vdGUgdXBvbiByZXF1ZXN0LFxuLy8gaW5zdGVhZCBvZiBwYXNzaW5nIGEgcmVmZXJlbmNlLlxuUS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSWYgdHdvIHByb21pc2VzIGV2ZW50dWFsbHkgZnVsZmlsbCB0byB0aGUgc2FtZSB2YWx1ZSwgcHJvbWlzZXMgdGhhdCB2YWx1ZSxcbiAqIGJ1dCBvdGhlcndpc2UgcmVqZWN0cy5cbiAqIEBwYXJhbSB4IHtBbnkqfVxuICogQHBhcmFtIHkge0FueSp9XG4gKiBAcmV0dXJucyB7QW55Kn0gYSBwcm9taXNlIGZvciB4IGFuZCB5IGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBidXQgYSByZWplY3Rpb25cbiAqIG90aGVyd2lzZS5cbiAqXG4gKi9cblEuam9pbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIFEoeCkuam9pbih5KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAodGhhdCkge1xuICAgIHJldHVybiBRKFt0aGlzLCB0aGF0XSkuc3ByZWFkKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBcIj09PVwiIHNob3VsZCBiZSBPYmplY3QuaXMgb3IgZXF1aXZcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUSBjYW4ndCBqb2luOiBub3QgdGhlIHNhbWU6IFwiICsgeCArIFwiIFwiICsgeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBmaXJzdCBvZiBhbiBhcnJheSBvZiBwcm9taXNlcyB0byBiZWNvbWUgc2V0dGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIHNldHRsZWRcbiAqL1xuUS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoYW5zd2VyUHMpIHtcbiAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byB0aGlzIG9uY2Ugd2UgY2FuIGFzc3VtZSBhdCBsZWFzdCBFUzVcbiAgICAgICAgLy8gYW5zd2VyUHMuZm9yRWFjaChmdW5jdGlvbiAoYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG5cbiAgICBmdW5jdGlvbiBfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiID8gZnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWplY3RlZChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXhjZXB0aW9uLCBzZWxmKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ld0V4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wcm9ncmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvZ3Jlc3NlZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvZ3Jlc3NlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9mdWxmaWxsZWQodmFsdWUpKTtcbiAgICAgICAgfSwgXCJ3aGVuXCIsIFtmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9yZWplY3RlZChleGNlcHRpb24pKTtcbiAgICAgICAgfV0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvZ3Jlc3MgcHJvcGFnYXRvciBuZWVkIHRvIGJlIGF0dGFjaGVkIGluIHRoZSBjdXJyZW50IHRpY2suXG4gICAgc2VsZi5wcm9taXNlRGlzcGF0Y2godm9pZCAwLCBcIndoZW5cIiwgW3ZvaWQgMCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9wcm9ncmVzc2VkKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblEudGFwID0gZnVuY3Rpb24gKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGFwKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogV29ya3MgYWxtb3N0IGxpa2UgXCJmaW5hbGx5XCIsIGJ1dCBub3QgY2FsbGVkIGZvciByZWplY3Rpb25zLlxuICogT3JpZ2luYWwgcmVzb2x1dGlvbiB2YWx1ZSBpcyBwYXNzZWQgdGhyb3VnaCBjYWxsYmFjayB1bmFmZmVjdGVkLlxuICogQ2FsbGJhY2sgbWF5IHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGF3YWl0ZWQgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtRLlByb21pc2V9XG4gKiBAZXhhbXBsZVxuICogZG9Tb21ldGhpbmcoKVxuICogICAudGhlbiguLi4pXG4gKiAgIC50YXAoY29uc29sZS5sb2cpXG4gKiAgIC50aGVuKC4uLik7XG4gKi9cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwodmFsdWUpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIG9ic2VydmVyIG9uIGEgcHJvbWlzZS5cbiAqXG4gKiBHdWFyYW50ZWVzOlxuICpcbiAqIDEuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gKiAyLiB0aGF0IGVpdGhlciB0aGUgZnVsZmlsbGVkIGNhbGxiYWNrIG9yIHRoZSByZWplY3RlZCBjYWxsYmFjayB3aWxsIGJlXG4gKiAgICBjYWxsZWQsIGJ1dCBub3QgYm90aC5cbiAqIDMuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIG5vdCBiZSBjYWxsZWQgaW4gdGhpcyB0dXJuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSB0byBvYnNlcnZlXG4gKiBAcGFyYW0gZnVsZmlsbGVkICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiBAcGFyYW0gcmVqZWN0ZWQgICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcmVqZWN0aW9uIGV4Y2VwdGlvblxuICogQHBhcmFtIHByb2dyZXNzZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgaW52b2tlZCBjYWxsYmFja1xuICovXG5RLndoZW4gPSB3aGVuO1xuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufTtcblxuUS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IHJlYXNvbjsgfSk7XG59O1xuXG5RLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlamVjdChyZWFzb24pO1xufTtcblxuLyoqXG4gKiBJZiBhbiBvYmplY3QgaXMgbm90IGEgcHJvbWlzZSwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUuXG4gKiBJZiBhIHByb21pc2UgaXMgcmVqZWN0ZWQsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlIHRvby5cbiAqIElmIGl04oCZcyBhIGZ1bGZpbGxlZCBwcm9taXNlLCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmVhcmVyLlxuICogSWYgaXTigJlzIGEgZGVmZXJyZWQgcHJvbWlzZSBhbmQgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLCB0aGVcbiAqIHJlc29sdXRpb24gaXMgXCJuZWFyZXJcIi5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIG1vc3QgcmVzb2x2ZWQgKG5lYXJlc3QpIGZvcm0gb2YgdGhlIG9iamVjdFxuICovXG5cbi8vIFhYWCBzaG91bGQgd2UgcmUtZG8gdGhpcz9cblEubmVhcmVyID0gbmVhcmVyO1xuZnVuY3Rpb24gbmVhcmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHZhbHVlLmluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZS5cbiAqIE90aGVyd2lzZSBpdCBpcyBhIGZ1bGZpbGxlZCB2YWx1ZS5cbiAqL1xuUS5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFByb21pc2U7XG59XG5cblEuaXNQcm9taXNlQWxpa2UgPSBpc1Byb21pc2VBbGlrZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUFsaWtlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgbWVhbmluZyBub3RcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAqL1xuUS5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG5mdW5jdGlvbiBpc1BlbmRpbmcob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsdWUgb3IgZnVsZmlsbGVkXG4gKiBwcm9taXNlLlxuICovXG5RLmlzRnVsZmlsbGVkID0gaXNGdWxmaWxsZWQ7XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZChvYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUHJvbWlzZShvYmplY3QpIHx8IG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuUS5pc1JlamVjdGVkID0gaXNSZWplY3RlZDtcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn07XG5cbi8vLy8gQkVHSU4gVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vLyBUaGlzIHByb21pc2UgbGlicmFyeSBjb25zdW1lcyBleGNlcHRpb25zIHRocm93biBpbiBoYW5kbGVycyBzbyB0aGV5IGNhbiBiZVxuLy8gaGFuZGxlZCBieSBhIHN1YnNlcXVlbnQgcHJvbWlzZS4gIFRoZSBleGNlcHRpb25zIGdldCBhZGRlZCB0byB0aGlzIGFycmF5IHdoZW5cbi8vIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSBhcmUgaGFuZGxlZC4gIE5vdGUgdGhhdCBpbiBFUzYgb3Jcbi8vIHNoaW1tZWQgZW52aXJvbm1lbnRzLCB0aGlzIHdvdWxkIG5hdHVyYWxseSBiZSBhIGBTZXRgLlxudmFyIHVuaGFuZGxlZFJlYXNvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIFEubmV4dFRpY2sucnVuQWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24uc3RhY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKHJlYXNvbi5zdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKFwiKG5vIHN0YWNrKSBcIiArIHJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2sucnVuQWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdFJlcG9ydCA9IGFycmF5X2luZGV4T2YocmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICBpZiAoYXRSZXBvcnQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInJlamVjdGlvbkhhbmRsZWRcIiwgdW5oYW5kbGVkUmVhc29uc1thdF0sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0UmVwb3J0LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdCwgMSk7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICB9XG59XG5cblEucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zID0gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zO1xuXG5RLmdldFVuaGFuZGxlZFJlYXNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gdGhhdCBjb25zdW1lcnMgY2FuJ3QgaW50ZXJmZXJlIHdpdGggb3VyIGludGVybmFsIHN0YXRlLlxuICAgIHJldHVybiB1bmhhbmRsZWRSZWFzb25zLnNsaWNlKCk7XG59O1xuXG5RLnN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8qKlxuICogQW5ub3RhdGVzIGFuIG9iamVjdCBzdWNoIHRoYXQgaXQgd2lsbCBuZXZlciBiZVxuICogdHJhbnNmZXJyZWQgYXdheSBmcm9tIHRoaXMgcHJvY2VzcyBvdmVyIGFueSBwcm9taXNlXG4gKiBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBwcm9taXNlIGEgd3JhcHBpbmcgb2YgdGhhdCBvYmplY3QgdGhhdFxuICogYWRkaXRpb25hbGx5IHJlc3BvbmRzIHRvIHRoZSBcImlzRGVmXCIgbWVzc2FnZVxuICogd2l0aG91dCBhIHJlamVjdGlvbi5cbiAqL1xuUS5tYXN0ZXIgPSBtYXN0ZXI7XG5mdW5jdGlvbiBtYXN0ZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcImlzRGVmXCI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2sob3AsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFEob2JqZWN0KS5pbnNwZWN0KCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gc3ByZWFkO1xuZnVuY3Rpb24gc3ByZWFkKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnNwcmVhZChmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkLmFwcGx5KHZvaWQgMCwgYXJyYXkpO1xuICAgIH0sIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuICBBbHRob3VnaCBnZW5lcmF0b3JzIGFyZSBvbmx5IHBhcnRcbiAqIG9mIHRoZSBuZXdlc3QgRUNNQVNjcmlwdCA2IGRyYWZ0cywgdGhpcyBjb2RlIGRvZXMgbm90IGNhdXNlIHN5bnRheFxuICogZXJyb3JzIGluIG9sZGVyIGVuZ2luZXMuICBUaGlzIGNvZGUgc2hvdWxkIGNvbnRpbnVlIHRvIHdvcmsgYW5kIHdpbGxcbiAqIGluIGZhY3QgaW1wcm92ZSBvdmVyIHRpbWUgYXMgdGhlIGxhbmd1YWdlIGltcHJvdmVzLlxuICpcbiAqIEVTNiBnZW5lcmF0b3JzIGFyZSBjdXJyZW50bHkgcGFydCBvZiBWOCB2ZXJzaW9uIDMuMTkgd2l0aCB0aGVcbiAqIC0taGFybW9ueS1nZW5lcmF0b3JzIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiAgU3BpZGVyTW9ua2V5IGhhcyBoYWQgdGhlbVxuICogZm9yIGxvbmdlciwgYnV0IHVuZGVyIGFuIG9sZGVyIFB5dGhvbi1pbnNwaXJlZCBmb3JtLiAgVGhpcyBmdW5jdGlvblxuICogd29ya3Mgb24gYm90aCBraW5kcyBvZiBnZW5lcmF0b3JzLlxuICpcbiAqIERlY29yYXRlcyBhIGdlbmVyYXRvciBmdW5jdGlvbiBzdWNoIHRoYXQ6XG4gKiAgLSBpdCBtYXkgeWllbGQgcHJvbWlzZXNcbiAqICAtIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHdoZW4gdGhhdCBwcm9taXNlIGlzIGZ1bGZpbGxlZFxuICogIC0gdGhlIHZhbHVlIG9mIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpbGwgYmUgdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogIC0gaXQgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgKHdoZW4gdGhlIGdlbmVyYXRvclxuICogICAgc3RvcHMgaXRlcmF0aW5nKVxuICogIC0gdGhlIGRlY29yYXRlZCBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogICAgb2YgdGhlIGdlbmVyYXRvciBvciB0aGUgZmlyc3QgcmVqZWN0ZWQgcHJvbWlzZSBhbW9uZyB0aG9zZVxuICogICAgeWllbGRlZC5cbiAqICAtIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgZ2VuZXJhdG9yLCBpdCBwcm9wYWdhdGVzIHRocm91Z2hcbiAqICAgIGV2ZXJ5IGZvbGxvd2luZyB5aWVsZCB1bnRpbCBpdCBpcyBjYXVnaHQsIG9yIHVudGlsIGl0IGVzY2FwZXNcbiAqICAgIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gYWx0b2dldGhlciwgYW5kIGlzIHRyYW5zbGF0ZWQgaW50byBhXG4gKiAgICByZWplY3Rpb24gZm9yIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgZ2VuZXJhdG9yLlxuICovXG5RLmFzeW5jID0gYXN5bmM7XG5mdW5jdGlvbiBhc3luYyhtYWtlR2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwic2VuZFwiLCBhcmcgaXMgYSB2YWx1ZVxuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJ0aHJvd1wiLCBhcmcgaXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlcih2ZXJiLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuICAgICAgICAgICAgLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbiAgICAgICAgICAgIC8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbiAgICAgICAgICAgIC8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhpcyBibG9jay5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdG9wSXRlcmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRVM2IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNwaWRlck1vbmtleSBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGNhc2Ugd2hlbiBTTSBkb2VzIEVTNiBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBRKGV4Y2VwdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IG1ha2VHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcIm5leHRcIik7XG4gICAgICAgIHZhciBlcnJiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcInRocm93XCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzcGF3biBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIGFzeW5jIHRoYXQgaW1tZWRpYXRlbHlcbiAqIGNhbGxzIHRoZSBnZW5lcmF0b3IgYW5kIGFsc28gZW5kcyB0aGUgcHJvbWlzZSBjaGFpbiwgc28gdGhhdCBhbnlcbiAqIHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIGZvcndhcmRlZCB0byB0aGUgZXJyb3JcbiAqIGhhbmRsZXIuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBleHRyZW1lbHkgY29tbW9uIHRvIHJ1blxuICogZ2VuZXJhdG9ycyBhdCB0aGUgdG9wLWxldmVsIHRvIHdvcmsgd2l0aCBsaWJyYXJpZXMuXG4gKi9cblEuc3Bhd24gPSBzcGF3bjtcbmZ1bmN0aW9uIHNwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRLmRvbmUoUS5hc3luYyhtYWtlR2VuZXJhdG9yKSgpKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGludGVyZmFjZSBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG4vKipcbiAqIFRocm93cyBhIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB0byBzdG9wIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3IuXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgYSBzdG9wLWdhcCBtZWFzdXJlIHRvIHN1cHBvcnQgZ2VuZXJhdG9yIHJldHVyblxuICogdmFsdWVzIGluIG9sZGVyIEZpcmVmb3gvU3BpZGVyTW9ua2V5LiAgSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEVTNlxuICogZ2VuZXJhdG9ycyBsaWtlIENocm9taXVtIDI5LCBqdXN0IHVzZSBcInJldHVyblwiIGluIHlvdXIgZ2VuZXJhdG9yXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoZSBzdXJyb3VuZGluZyBnZW5lcmF0b3JcbiAqIEB0aHJvd3MgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHdpdGggdGhlIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIEVTNiBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiogKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICByZXR1cm4gZm9vICsgYmFyO1xuICogfSlcbiAqIC8vIE9sZGVyIFNwaWRlck1vbmtleSBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIFEucmV0dXJuKGZvbyArIGJhcik7XG4gKiB9KVxuICovXG5RW1wicmV0dXJuXCJdID0gX3JldHVybjtcbmZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgUVJldHVyblZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IHByb21pc2VkO1xuZnVuY3Rpb24gcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkKFt0aGlzLCBhbGwoYXJndW1lbnRzKV0sIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogc2VuZHMgYSBtZXNzYWdlIHRvIGEgdmFsdWUgaW4gYSBmdXR1cmUgdHVyblxuICogQHBhcmFtIG9iamVjdCogdGhlIHJlY2lwaWVudFxuICogQHBhcmFtIG9wIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIG9wZXJhdGlvbiwgZS5nLiwgXCJ3aGVuXCIsXG4gKiBAcGFyYW0gYXJncyBmdXJ0aGVyIGFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgcmVzdWx0IHtQcm9taXNlfSBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5RLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5mdW5jdGlvbiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChvcCwgYXJncyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKG9wLCBhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGRlZmVycmVkLnJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBnZXRcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlXG4gKi9cblEuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHZhbHVlICAgICBuZXcgdmFsdWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBkZWxldGVcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLmRlbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gdmFsdWUgICAgIGEgdmFsdWUgdG8gcG9zdCwgdHlwaWNhbGx5IGFuIGFycmF5IG9mXG4gKiAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gYXJndW1lbnRzIGZvciBwcm9taXNlcyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgIGFyZSB1bHRpbWF0ZWx5IGJhY2tlZCB3aXRoIGByZXNvbHZlYCB2YWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgIGFzIG9wcG9zZWQgdG8gdGhvc2UgYmFja2VkIHdpdGggVVJMc1xuICogICAgICAgICAgICAgICAgICB3aGVyZWluIHRoZSBwb3N0ZWQgdmFsdWUgY2FuIGJlIGFueVxuICogICAgICAgICAgICAgICAgICBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuLy8gYm91bmQgbG9jYWxseSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgb3RoZXIgbWV0aG9kc1xuUS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBpbnZvY2F0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5RLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEuaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblByb21pc2UucHJvdG90eXBlLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXJncyAgICAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZhcHBseSA9IGZ1bmN0aW9uIChvYmplY3QsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RW1widHJ5XCJdID1cblEuZmNhbGwgPSBmdW5jdGlvbiAob2JqZWN0IC8qIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzKV0pO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24sIHRyYW5zZm9ybWluZyByZXR1cm4gdmFsdWVzIGludG8gYSBmdWxmaWxsZWRcbiAqIHByb21pc2UgYW5kIHRocm93biBlcnJvcnMgaW50byBhIHJlamVjdGVkIG9uZS5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmJpbmQgPSBmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuZmJpbmQgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBuYW1lcyBvZiB0aGUgb3duZWQgcHJvcGVydGllcyBvZiBhIHByb21pc2VkXG4gKiBvYmplY3QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBrZXlzIG9mIHRoZSBldmVudHVhbGx5IHNldHRsZWQgb2JqZWN0XG4gKi9cblEua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZlxuICogdGhlIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG4vLyBCeSBNYXJrIE1pbGxlclxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46Y29uY3VycmVuY3kmcmV2PTEzMDg3NzY1MjEjYWxsZnVsZmlsbGVkXG5RLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvbWlzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgICAgICAoc25hcHNob3QgPSBwcm9taXNlLmluc3BlY3QoKSkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHNuYXBzaG90LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3BlbmRpbmdDb3VudDtcbiAgICAgICAgICAgICAgICB3aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tcGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoeyBpbmRleDogaW5kZXgsIHZhbHVlOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIGlmIChwZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZSBvZiBhbiBhcnJheS4gUHJpb3IgcmVqZWN0ZWQgcHJvbWlzZXMgYXJlXG4gKiBpZ25vcmVkLiAgUmVqZWN0cyBvbmx5IGlmIGFsbCBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgY29udGFpbmluZyB2YWx1ZXMgb3IgcHJvbWlzZXMgZm9yIHZhbHVlc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZSxcbiAqIG9yIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICovXG5RLmFueSA9IGFueTtcblxuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmVycmVkID0gUS5kZWZlcigpO1xuICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gcHJvbWlzZXNbaW5kZXhdO1xuXG4gICAgICAgIHBlbmRpbmdDb3VudCsrO1xuXG4gICAgICAgIHdoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpO1xuICAgICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXN1bHQpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblJlamVjdGVkKGVycikge1xuICAgICAgICAgICAgcGVuZGluZ0NvdW50LS07XG4gICAgICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlamVjdGlvbiA9IGVyciB8fCBuZXcgRXJyb3IoXCJcIiArIGVycik7XG5cbiAgICAgICAgICAgICAgICByZWplY3Rpb24ubWVzc2FnZSA9IChcIlEgY2FuJ3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIGZyb20gYW55IHByb21pc2UsIGFsbCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwicHJvbWlzZXMgd2VyZSByZWplY3RlZC4gTGFzdCBlcnJvciBtZXNzYWdlOiBcIiArIHJlamVjdGlvbi5tZXNzYWdlKTtcblxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChyZWplY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9ncmVzc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB1bmRlZmluZWQpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIHRvIGJlIHNldHRsZWQsIGVpdGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiAgVGhpcyBpcyBkaXN0aW5jdCBmcm9tIGBhbGxgIHNpbmNlIHRoYXQgd291bGQgc3RvcFxuICogd2FpdGluZyBhdCB0aGUgZmlyc3QgcmVqZWN0aW9uLiAgVGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAqIGBhbGxSZXNvbHZlZGAgd2lsbCBuZXZlciBiZSByZWplY3RlZC5cbiAqIEBwYXJhbSBwcm9taXNlcyBhIHByb21pc2UgZm9yIGFuIGFycmF5IChvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcbiAqIChvciB2YWx1ZXMpXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXNcbiAqL1xuUS5hbGxSZXNvbHZlZCA9IGRlcHJlY2F0ZShhbGxSZXNvbHZlZCwgXCJhbGxSZXNvbHZlZFwiLCBcImFsbFNldHRsZWRcIik7XG5mdW5jdGlvbiBhbGxSZXNvbHZlZChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcHJvbWlzZXMgPSBhcnJheV9tYXAocHJvbWlzZXMsIFEpO1xuICAgICAgICByZXR1cm4gd2hlbihhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbFJlc29sdmVkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAc2VlIFByb21pc2UjYWxsU2V0dGxlZFxuICovXG5RLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xuICAgIHJldHVybiBRKHByb21pc2VzKS5hbGxTZXR0bGVkKCk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUShwcm9taXNlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2FyZGxlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZWdhcmRsZXNzLCByZWdhcmRsZXNzKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgZmFpbHVyZSBvZiBhIHByb21pc2UsIGdpdmluZyBhbiBvcG9ydHVuaXR5IHRvIHJlY292ZXJcbiAqIHdpdGggYSBjYWxsYmFjay4gIElmIHRoZSBnaXZlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gKiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlmIHRoZVxuICogZ2l2ZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFja1xuICovXG5RLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBsaXN0ZW5lciB0aGF0IGNhbiByZXNwb25kIHRvIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZnJvbSBhXG4gKiBwcm9taXNlJ3Mgb3JpZ2luYXRpbmcgZGVmZXJyZWQuIFRoaXMgbGlzdGVuZXIgcmVjZWl2ZXMgdGhlIGV4YWN0IGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGBgZGVmZXJyZWQubm90aWZ5YGAuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybnMgdGhlIGdpdmVuIHByb21pc2UsIHVuY2hhbmdlZFxuICovXG5RLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5mdW5jdGlvbiBwcm9ncmVzcyhvYmplY3QsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIG9ic2VydmUgdGhlIHNldHRsaW5nIG9mIGEgcHJvbWlzZSxcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBGb3J3YXJkc1xuICogdGhlIHJlc29sdXRpb24gdG8gdGhlIHJldHVybmVkIHByb21pc2Ugd2hlbiB0aGUgY2FsbGJhY2sgaXMgZG9uZS5cbiAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBjb21wbGV0aW9uLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBvYnNlcnZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlblxuICogcHJvbWlzZSwgdGFrZXMgbm8gYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSB3aGVuXG4gKiBgYGZpbmBgIGlzIGRvbmUuXG4gKi9cblEuZmluID0gLy8gWFhYIGxlZ2FjeVxuUVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdClbXCJmaW5hbGx5XCJdKGNhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZpbiA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrLmFwcGx5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUSBjYW4ndCBhcHBseSBmaW5hbGx5IGNhbGxiYWNrXCIpO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRPRE8gYXR0ZW1wdCB0byByZWN5Y2xlIHRoZSByZWplY3Rpb24gd2l0aCBcInRoaXNcIi5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGEgY2hhaW4gb2YgcHJvbWlzZXMsIGZvcmNpbmcgcmVqZWN0aW9ucyB0byBiZVxuICogdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgYXQgdGhlIGVuZCBvZiBhIGNoYWluIG9mIHByb21pc2VzXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cblEuZG9uZSA9IGZ1bmN0aW9uIChvYmplY3QsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kb25lKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBmb3J3YXJkIHRvIGEgZnV0dXJlIHR1cm4gc28gdGhhdCBgYHdoZW5gYFxuICAgICAgICAvLyBkb2VzIG5vdCBjYXRjaCBpdCBhbmQgdHVybiBpdCBpbnRvIGEgcmVqZWN0aW9uLlxuICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBgbmV4dFRpY2tgaW5nIHZpYSBhbiB1bm5lY2Vzc2FyeSBgd2hlbmAuXG4gICAgdmFyIHByb21pc2UgPSBmdWxmaWxsZWQgfHwgcmVqZWN0ZWQgfHwgcHJvZ3Jlc3MgP1xuICAgICAgICB0aGlzLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIDpcbiAgICAgICAgdGhpcztcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3IgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbih2b2lkIDAsIG9uVW5oYW5kbGVkRXJyb3IpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kcyB0aW1lb3V0XG4gKiBAcGFyYW0ge0FueSp9IGN1c3RvbSBlcnJvciBtZXNzYWdlIG9yIEVycm9yIG9iamVjdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGlmIGl0IGlzXG4gKiBmdWxmaWxsZWQgYmVmb3JlIHRoZSB0aW1lb3V0LCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gKi9cblEudGltZW91dCA9IGZ1bmN0aW9uIChvYmplY3QsIG1zLCBlcnJvcikge1xuICAgIHJldHVybiBRKG9iamVjdCkudGltZW91dChtcywgZXJyb3IpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgZXJyb3IpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlcnJvciB8fCBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yIHx8IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgbXMgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgfSwgbXMpO1xuXG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfSwgZGVmZXJyZWQubm90aWZ5KTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGdpdmVuIHZhbHVlIChvciBwcm9taXNlZCB2YWx1ZSksIHNvbWVcbiAqIG1pbGxpc2Vjb25kcyBhZnRlciBpdCByZXNvbHZlZC4gUGFzc2VzIHJlamVjdGlvbnMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgYWZ0ZXIgbWlsbGlzZWNvbmRzXG4gKiB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlLlxuICogSWYgdGhlIGdpdmVuIHByb21pc2UgcmVqZWN0cywgdGhhdCBpcyBwYXNzZWQgaW1tZWRpYXRlbHkuXG4gKi9cblEuZGVsYXkgPSBmdW5jdGlvbiAob2JqZWN0LCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lb3V0ID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBRKG9iamVjdCkuZGVsYXkodGltZW91dCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBhcyBhbiBhcnJheSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqICAgICAgUS5uZmFwcGx5KEZTLnJlYWRGaWxlLCBbX19maWxlbmFtZV0pXG4gKiAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiAgICAgIH0pXG4gKlxuICovXG5RLm5mYXBwbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGluZGl2aWR1YWxseSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZjYWxsKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKVxuICogLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqIH0pXG4gKlxuICovXG5RLm5mY2FsbCA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBOb2RlSlMgY29udGludWF0aW9uIHBhc3NpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudFxuICogdmVyc2lvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZiaW5kKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKShcInV0Zi04XCIpXG4gKiAudGhlbihjb25zb2xlLmxvZylcbiAqIC5kb25lKClcbiAqL1xuUS5uZmJpbmQgPVxuUS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRIGNhbid0IHdyYXAgYW4gdW5kZWZpbmVkIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBRKGNhbGxiYWNrKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYmluZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLmRlbm9kZWlmeS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuUS5uYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3AgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBRKGJvdW5kKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5iaW5kID0gZnVuY3Rpb24gKC8qdGhpc3AsIC4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEubmJpbmQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjayB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWQgY2FsbGJhY2suXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5ucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5wb3N0KG5hbWUsIGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5ucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyB8fCBbXSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrLCBmb3J3YXJkaW5nIHRoZSBnaXZlbiB2YXJpYWRpYyBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZFxuICogY2FsbGJhY2sgYXJndW1lbnQuXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0gLi4uYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2sgd2lsbFxuICogYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5RLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblEubmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUHJvbWlzZS5wcm90b3R5cGUubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUHJvbWlzZS5wcm90b3R5cGUubmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIElmIGEgZnVuY3Rpb24gd291bGQgbGlrZSB0byBzdXBwb3J0IGJvdGggTm9kZSBjb250aW51YXRpb24tcGFzc2luZy1zdHlsZSBhbmRcbiAqIHByb21pc2UtcmV0dXJuaW5nLXN0eWxlLCBpdCBjYW4gZW5kIGl0cyBpbnRlcm5hbCBwcm9taXNlIGNoYWluIHdpdGhcbiAqIGBub2RlaWZ5KG5vZGViYWNrKWAsIGZvcndhcmRpbmcgdGhlIG9wdGlvbmFsIG5vZGViYWNrIGFyZ3VtZW50LiAgSWYgdGhlIHVzZXJcbiAqIGVsZWN0cyB0byB1c2UgYSBub2RlYmFjaywgdGhlIHJlc3VsdCB3aWxsIGJlIHNlbnQgdGhlcmUuICBJZiB0aGV5IGRvIG5vdFxuICogcGFzcyBhIG5vZGViYWNrLCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IHByb21pc2UuXG4gKiBAcGFyYW0gb2JqZWN0IGEgcmVzdWx0IChvciBhIHByb21pc2UgZm9yIGEgcmVzdWx0KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbm9kZWJhY2sgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyBlaXRoZXIgdGhlIHByb21pc2Ugb3Igbm90aGluZ1xuICovXG5RLm5vZGVpZnkgPSBub2RlaWZ5O1xuZnVuY3Rpb24gbm9kZWlmeShvYmplY3QsIG5vZGViYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ub2RlaWZ5KG5vZGViYWNrKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaykge1xuICAgIGlmIChub2RlYmFjaykge1xuICAgICAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuUS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUS5ub0NvbmZsaWN0IG9ubHkgd29ya3Mgd2hlbiBRIGlzIHVzZWQgYXMgYSBnbG9iYWxcIik7XG59O1xuXG4vLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxudmFyIHFFbmRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcblxucmV0dXJuIFE7XG5cbn0pO1xuIl0sIm5hbWVzIjpbImRlZmluaXRpb24iLCJib290c3RyYXAiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwic2VzIiwib2siLCJtYWtlUSIsInNlbGYiLCJnbG9iYWwiLCJ3aW5kb3ciLCJwcmV2aW91c1EiLCJRIiwibm9Db25mbGljdCIsIkVycm9yIiwiaGFzU3RhY2tzIiwiZSIsInN0YWNrIiwicVN0YXJ0aW5nTGluZSIsImNhcHR1cmVMaW5lIiwicUZpbGVOYW1lIiwibm9vcCIsIm5leHRUaWNrIiwiaGVhZCIsInRhc2siLCJuZXh0IiwidGFpbCIsImZsdXNoaW5nIiwicmVxdWVzdFRpY2siLCJpc05vZGVKUyIsImxhdGVyUXVldWUiLCJmbHVzaCIsImRvbWFpbiIsImVudGVyIiwicnVuU2luZ2xlIiwibGVuZ3RoIiwicG9wIiwiZXhpdCIsInNldFRpbWVvdXQiLCJwcm9jZXNzIiwidG9TdHJpbmciLCJzZXRJbW1lZGlhdGUiLCJiaW5kIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJyZXF1ZXN0UG9ydFRpY2siLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwicnVuQWZ0ZXIiLCJwdXNoIiwiY2FsbCIsIkZ1bmN0aW9uIiwidW5jdXJyeVRoaXMiLCJmIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJhcnJheV9zbGljZSIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJhcnJheV9yZWR1Y2UiLCJyZWR1Y2UiLCJjYWxsYmFjayIsImJhc2lzIiwiaW5kZXgiLCJUeXBlRXJyb3IiLCJhcnJheV9pbmRleE9mIiwiaW5kZXhPZiIsInZhbHVlIiwiaSIsImFycmF5X21hcCIsIm1hcCIsInRoaXNwIiwiY29sbGVjdCIsInVuZGVmaW5lZCIsIm9iamVjdF9jcmVhdGUiLCJPYmplY3QiLCJjcmVhdGUiLCJUeXBlIiwib2JqZWN0X2RlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJwcm9wIiwiZGVzY3JpcHRvciIsIm9iamVjdF9oYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5Iiwib2JqZWN0X2tleXMiLCJrZXlzIiwib2JqZWN0Iiwia2V5Iiwib2JqZWN0X3RvU3RyaW5nIiwiaXNPYmplY3QiLCJpc1N0b3BJdGVyYXRpb24iLCJleGNlcHRpb24iLCJRUmV0dXJuVmFsdWUiLCJSZXR1cm5WYWx1ZSIsIlNUQUNLX0pVTVBfU0VQQVJBVE9SIiwibWFrZVN0YWNrVHJhY2VMb25nIiwiZXJyb3IiLCJwcm9taXNlIiwic3RhY2tzIiwicCIsInNvdXJjZSIsIl9fbWluaW11bVN0YWNrQ291bnRlcl9fIiwic3RhY2tDb3VudGVyIiwiY29uZmlndXJhYmxlIiwidW5zaGlmdCIsImNvbmNhdGVkU3RhY2tzIiwiam9pbiIsImZpbHRlclN0YWNrU3RyaW5nIiwic3RhY2tTdHJpbmciLCJsaW5lcyIsInNwbGl0IiwiZGVzaXJlZExpbmVzIiwibGluZSIsImlzSW50ZXJuYWxGcmFtZSIsImlzTm9kZUZyYW1lIiwic3RhY2tMaW5lIiwiZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyIiwiYXR0ZW1wdDEiLCJleGVjIiwiTnVtYmVyIiwiYXR0ZW1wdDIiLCJhdHRlbXB0MyIsImZpbGVOYW1lQW5kTGluZU51bWJlciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsInFFbmRpbmdMaW5lIiwiZmlyc3RMaW5lIiwiZGVwcmVjYXRlIiwibmFtZSIsImFsdGVybmF0aXZlIiwiY29uc29sZSIsIndhcm4iLCJQcm9taXNlIiwiaXNQcm9taXNlQWxpa2UiLCJjb2VyY2UiLCJmdWxmaWxsIiwicmVzb2x2ZSIsImxvbmdTdGFja1N1cHBvcnQiLCJsb25nU3RhY2tDb3VudGVyIiwiZW52IiwiUV9ERUJVRyIsImRlZmVyIiwibWVzc2FnZXMiLCJwcm9ncmVzc0xpc3RlbmVycyIsInJlc29sdmVkUHJvbWlzZSIsImRlZmVycmVkIiwicHJvbWlzZURpc3BhdGNoIiwib3AiLCJvcGVyYW5kcyIsImFyZ3MiLCJ2YWx1ZU9mIiwibmVhcmVyVmFsdWUiLCJuZWFyZXIiLCJpc1Byb21pc2UiLCJpbnNwZWN0Iiwic3RhdGUiLCJzdWJzdHJpbmciLCJiZWNvbWUiLCJuZXdQcm9taXNlIiwibWVzc2FnZSIsInJlamVjdCIsInJlYXNvbiIsIm5vdGlmeSIsInByb2dyZXNzIiwicHJvZ3Jlc3NMaXN0ZW5lciIsIm1ha2VOb2RlUmVzb2x2ZXIiLCJyZXNvbHZlciIsInJhY2UiLCJhbGwiLCJwYXNzQnlDb3B5IiwieCIsInkiLCJ0aGF0Iiwic3ByZWFkIiwiYW5zd2VyUHMiLCJsZW4iLCJ0aGVuIiwibWFrZVByb21pc2UiLCJmYWxsYmFjayIsInJlc3VsdCIsImluc3BlY3RlZCIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwicHJvZ3Jlc3NlZCIsImRvbmUiLCJfZnVsZmlsbGVkIiwiX3JlamVjdGVkIiwibmV3RXhjZXB0aW9uIiwiX3Byb2dyZXNzZWQiLCJuZXdWYWx1ZSIsInRocmV3Iiwib25lcnJvciIsInRhcCIsImZjYWxsIiwidGhlblJlc29sdmUiLCJ3aGVuIiwidGhlblJlamVjdCIsImlzUGVuZGluZyIsImlzRnVsZmlsbGVkIiwiaXNSZWplY3RlZCIsInVuaGFuZGxlZFJlYXNvbnMiLCJ1bmhhbmRsZWRSZWplY3Rpb25zIiwicmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zIiwidHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zIiwicmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zIiwidHJhY2tSZWplY3Rpb24iLCJlbWl0IiwidW50cmFja1JlamVjdGlvbiIsImF0IiwiYXRSZXBvcnQiLCJzcGxpY2UiLCJnZXRVbmhhbmRsZWRSZWFzb25zIiwic3RvcFVuaGFuZGxlZFJlamVjdGlvblRyYWNraW5nIiwicmVqZWN0aW9uIiwicmhzIiwibWFzdGVyIiwiZGlzcGF0Y2giLCJhcnJheSIsImFzeW5jIiwibWFrZUdlbmVyYXRvciIsImNvbnRpbnVlciIsInZlcmIiLCJhcmciLCJTdG9wSXRlcmF0aW9uIiwiZ2VuZXJhdG9yIiwiZXJyYmFjayIsInNwYXduIiwiX3JldHVybiIsInByb21pc2VkIiwiZ2V0Iiwic2V0IiwiZGVsIiwibWFwcGx5IiwicG9zdCIsInNlbmQiLCJtY2FsbCIsImludm9rZSIsImZhcHBseSIsImZiaW5kIiwiZmJvdW5kIiwiY29uY2F0IiwicHJvbWlzZXMiLCJwZW5kaW5nQ291bnQiLCJzbmFwc2hvdCIsImFueSIsInByZXYiLCJjdXJyZW50Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsImVyciIsImFsbFJlc29sdmVkIiwiYWxsU2V0dGxlZCIsInJlZ2FyZGxlc3MiLCJmYWlsIiwiZmluIiwib25VbmhhbmRsZWRFcnJvciIsInRpbWVvdXQiLCJtcyIsInRpbWVvdXRJZCIsImNvZGUiLCJjbGVhclRpbWVvdXQiLCJkZWxheSIsIm5mYXBwbHkiLCJub2RlQXJncyIsIm5mY2FsbCIsIm5mYmluZCIsImRlbm9kZWlmeSIsImJhc2VBcmdzIiwibmJpbmQiLCJib3VuZCIsIm5tYXBwbHkiLCJucG9zdCIsIm5zZW5kIiwibm1jYWxsIiwibmludm9rZSIsIm5vZGVpZnkiLCJub2RlYmFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/q/q.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/q/q.js":
/*!*****************************!*\
  !*** ./node_modules/q/q.js ***!
  \*****************************/
/***/ ((module) => {

eval("\n// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ (function(definition) {\n    \"use strict\";\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n    // CommonJS\n    } else if (true) {\n        module.exports = definition();\n    // RequireJS\n    } else { var previousQ, global; }\n})(function() {\n    \"use strict\";\n    var hasStacks = false;\n    try {\n        throw new Error();\n    } catch (e) {\n        hasStacks = !!e.stack;\n    }\n    // All code after this point will be filtered from stack traces reported\n    // by Q.\n    var qStartingLine = captureLine();\n    var qFileName;\n    // shims\n    // used for fallback in \"allResolved\"\n    var noop = function() {};\n    // Use the fastest possible means to execute a task in a future turn\n    // of the event loop.\n    var nextTick = function() {\n        // linked list of tasks (single, with head node)\n        var head = {\n            task: void 0,\n            next: null\n        };\n        var tail = head;\n        var flushing = false;\n        var requestTick = void 0;\n        var isNodeJS = false;\n        // queue for late tasks, used by unhandled rejection tracking\n        var laterQueue = [];\n        function flush() {\n            /* jshint loopfunc: true */ var task, domain;\n            while(head.next){\n                head = head.next;\n                task = head.task;\n                head.task = void 0;\n                domain = head.domain;\n                if (domain) {\n                    head.domain = void 0;\n                    domain.enter();\n                }\n                runSingle(task, domain);\n            }\n            while(laterQueue.length){\n                task = laterQueue.pop();\n                runSingle(task);\n            }\n            flushing = false;\n        }\n        // runs a single function in the async queue\n        function runSingle(task, domain) {\n            try {\n                task();\n            } catch (e) {\n                if (isNodeJS) {\n                    // In node, uncaught exceptions are considered fatal errors.\n                    // Re-throw them synchronously to interrupt flushing!\n                    // Ensure continuation if the uncaught exception is suppressed\n                    // listening \"uncaughtException\" events (as domains does).\n                    // Continue in next event to avoid tick recursion.\n                    if (domain) {\n                        domain.exit();\n                    }\n                    setTimeout(flush, 0);\n                    if (domain) {\n                        domain.enter();\n                    }\n                    throw e;\n                } else {\n                    // In browsers, uncaught exceptions are not fatal.\n                    // Re-throw them asynchronously to avoid slow-downs.\n                    setTimeout(function() {\n                        throw e;\n                    }, 0);\n                }\n            }\n            if (domain) {\n                domain.exit();\n            }\n        }\n        nextTick = function(task) {\n            tail = tail.next = {\n                task: task,\n                domain: isNodeJS && process.domain,\n                next: null\n            };\n            if (!flushing) {\n                flushing = true;\n                requestTick();\n            }\n        };\n        if (typeof process === \"object\" && process.toString() === \"[object process]\" && process.nextTick) {\n            // Ensure Q is in a real Node environment, with a `process.nextTick`.\n            // To see through fake Node environments:\n            // * Mocha test runner - exposes a `process` global without a `nextTick`\n            // * Browserify - exposes a `process.nexTick` function that uses\n            //   `setTimeout`. In this case `setImmediate` is preferred because\n            //    it is faster. Browserify's `process.toString()` yields\n            //   \"[object Object]\", while in a real Node environment\n            //   `process.toString()` yields \"[object process]\".\n            isNodeJS = true;\n            requestTick = function() {\n                process.nextTick(flush);\n            };\n        } else if (typeof setImmediate === \"function\") {\n            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n            if (false) {} else {\n                requestTick = function() {\n                    setImmediate(flush);\n                };\n            }\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // modern browsers\n            // http://www.nonblocking.io/2011/06/windownexttick.html\n            var channel = new MessageChannel();\n            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n            // working message ports the first time a page loads.\n            channel.port1.onmessage = function() {\n                requestTick = requestPortTick;\n                channel.port1.onmessage = flush;\n                flush();\n            };\n            var requestPortTick = function() {\n                // Opera requires us to provide a message payload, regardless of\n                // whether we use it.\n                channel.port2.postMessage(0);\n            };\n            requestTick = function() {\n                setTimeout(flush, 0);\n                requestPortTick();\n            };\n        } else {\n            // old browsers\n            requestTick = function() {\n                setTimeout(flush, 0);\n            };\n        }\n        // runs a task after all other tasks have been run\n        // this is useful for unhandled rejection tracking that needs to happen\n        // after all `then`d tasks have been run.\n        nextTick.runAfter = function(task) {\n            laterQueue.push(task);\n            if (!flushing) {\n                flushing = true;\n                requestTick();\n            }\n        };\n        return nextTick;\n    }();\n    // Attempt to make generics safe in the face of downstream\n    // modifications.\n    // There is no situation where this is necessary.\n    // If you need a security guarantee, these primordials need to be\n    // deeply frozen anyway, and if you don’t need a security guarantee,\n    // this is just plain paranoid.\n    // However, this **might** have the nice side-effect of reducing the size of\n    // the minified code by reducing x.call() to merely x()\n    // See Mark Miller’s explanation of what this does.\n    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n    var call = Function.call;\n    function uncurryThis(f) {\n        return function() {\n            return call.apply(f, arguments);\n        };\n    }\n    // This is equivalent, but slower:\n    // uncurryThis = Function_bind.bind(Function_bind.call);\n    // http://jsperf.com/uncurrythis\n    var array_slice = uncurryThis(Array.prototype.slice);\n    var array_reduce = uncurryThis(Array.prototype.reduce || function(callback, basis) {\n        var index = 0, length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            }while (1);\n        }\n        // reduce\n        for(; index < length; index++){\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    });\n    var array_indexOf = uncurryThis(Array.prototype.indexOf || function(value) {\n        // not a very good shim, but good enough for our one use of it\n        for(var i = 0; i < this.length; i++){\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    });\n    var array_map = uncurryThis(Array.prototype.map || function(callback, thisp) {\n        var self1 = this;\n        var collect = [];\n        array_reduce(self1, function(undefined1, value, index) {\n            collect.push(callback.call(thisp, value, index, self1));\n        }, void 0);\n        return collect;\n    });\n    var object_create = Object.create || function(prototype) {\n        function Type() {}\n        Type.prototype = prototype;\n        return new Type();\n    };\n    var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {\n        obj[prop] = descriptor.value;\n        return obj;\n    };\n    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n    var object_keys = Object.keys || function(object) {\n        var keys = [];\n        for(var key in object){\n            if (object_hasOwnProperty(object, key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    var object_toString = uncurryThis(Object.prototype.toString);\n    function isObject(value) {\n        return value === Object(value);\n    }\n    // generator related shims\n    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n    function isStopIteration(exception) {\n        return object_toString(exception) === \"[object StopIteration]\" || exception instanceof QReturnValue;\n    }\n    // FIXME: Remove this helper and Q.return once ES6 generators are in\n    // SpiderMonkey.\n    var QReturnValue;\n    if (typeof ReturnValue !== \"undefined\") {\n        QReturnValue = ReturnValue;\n    } else {\n        QReturnValue = function(value) {\n            this.value = value;\n        };\n    }\n    // long stack traces\n    var STACK_JUMP_SEPARATOR = \"From previous event:\";\n    function makeStackTraceLong(error, promise) {\n        // If possible, transform the error stack trace by removing Node and Q\n        // cruft, then concatenating with the stack trace of `promise`. See #57.\n        if (hasStacks && promise.stack && typeof error === \"object\" && error !== null && error.stack) {\n            var stacks = [];\n            for(var p = promise; !!p; p = p.source){\n                if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n                    object_defineProperty(error, \"__minimumStackCounter__\", {\n                        value: p.stackCounter,\n                        configurable: true\n                    });\n                    stacks.unshift(p.stack);\n                }\n            }\n            stacks.unshift(error.stack);\n            var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n            var stack = filterStackString(concatedStacks);\n            object_defineProperty(error, \"stack\", {\n                value: stack,\n                configurable: true\n            });\n        }\n    }\n    function filterStackString(stackString) {\n        var lines = stackString.split(\"\\n\");\n        var desiredLines = [];\n        for(var i = 0; i < lines.length; ++i){\n            var line = lines[i];\n            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n                desiredLines.push(line);\n            }\n        }\n        return desiredLines.join(\"\\n\");\n    }\n    function isNodeFrame(stackLine) {\n        return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n    }\n    function getFileNameAndLineNumber(stackLine) {\n        // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n        // In IE10 function name can have spaces (\"Anonymous function\") O_o\n        var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n        if (attempt1) {\n            return [\n                attempt1[1],\n                Number(attempt1[2])\n            ];\n        }\n        // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n        var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n        if (attempt2) {\n            return [\n                attempt2[1],\n                Number(attempt2[2])\n            ];\n        }\n        // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n        var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n        if (attempt3) {\n            return [\n                attempt3[1],\n                Number(attempt3[2])\n            ];\n        }\n    }\n    function isInternalFrame(stackLine) {\n        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n        if (!fileNameAndLineNumber) {\n            return false;\n        }\n        var fileName = fileNameAndLineNumber[0];\n        var lineNumber = fileNameAndLineNumber[1];\n        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;\n    }\n    // discover own file name and line number range for filtering stack\n    // traces\n    function captureLine() {\n        if (!hasStacks) {\n            return;\n        }\n        try {\n            throw new Error();\n        } catch (e) {\n            var lines = e.stack.split(\"\\n\");\n            var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n            if (!fileNameAndLineNumber) {\n                return;\n            }\n            qFileName = fileNameAndLineNumber[0];\n            return fileNameAndLineNumber[1];\n        }\n    }\n    function deprecate(callback, name, alternative) {\n        return function() {\n            if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n                console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n            }\n            return callback.apply(callback, arguments);\n        };\n    }\n    // end of shims\n    // beginning of real work\n    /**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */ function Q(value) {\n        // If the object is already a Promise, return it directly.  This enables\n        // the resolve function to both be used to created references from objects,\n        // but to tolerably coerce non-promises to promises.\n        if (value instanceof Promise) {\n            return value;\n        }\n        // assimilate thenables\n        if (isPromiseAlike(value)) {\n            return coerce(value);\n        } else {\n            return fulfill(value);\n        }\n    }\n    Q.resolve = Q;\n    /**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */ Q.nextTick = nextTick;\n    /**\n * Controls whether or not long stack traces will be on\n */ Q.longStackSupport = false;\n    /**\n * The counter is used to determine the stopping point for building\n * long stack traces. In makeStackTraceLong we walk backwards through\n * the linked list of promises, only stacks which were created before\n * the rejection are concatenated.\n */ var longStackCounter = 1;\n    // enable long stacks if Q_DEBUG is set\n    if (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n        Q.longStackSupport = true;\n    }\n    /**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */ Q.defer = defer;\n    function defer() {\n        // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n        // been resolved.  If it is \"undefined\", it has been resolved.  Each\n        // element of the messages array is itself an array of complete arguments to\n        // forward to the resolved promise.  We coerce the resolution value to a\n        // promise using the `resolve` function because it handles both fully\n        // non-thenable values and other thenables gracefully.\n        var messages = [], progressListeners = [], resolvedPromise;\n        var deferred = object_create(defer.prototype);\n        var promise = object_create(Promise.prototype);\n        promise.promiseDispatch = function(resolve, op, operands) {\n            var args = array_slice(arguments);\n            if (messages) {\n                messages.push(args);\n                if (op === \"when\" && operands[1]) {\n                    progressListeners.push(operands[1]);\n                }\n            } else {\n                Q.nextTick(function() {\n                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n                });\n            }\n        };\n        // XXX deprecated\n        promise.valueOf = function() {\n            if (messages) {\n                return promise;\n            }\n            var nearerValue = nearer(resolvedPromise);\n            if (isPromise(nearerValue)) {\n                resolvedPromise = nearerValue; // shorten chain\n            }\n            return nearerValue;\n        };\n        promise.inspect = function() {\n            if (!resolvedPromise) {\n                return {\n                    state: \"pending\"\n                };\n            }\n            return resolvedPromise.inspect();\n        };\n        if (Q.longStackSupport && hasStacks) {\n            try {\n                throw new Error();\n            } catch (e) {\n                // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n                // accessor around; that causes memory leaks as per GH-111. Just\n                // reify the stack trace as a string ASAP.\n                //\n                // At the same time, cut off the first line; it's always just\n                // \"[object Promise]\\n\", as per the `toString`.\n                promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n                promise.stackCounter = longStackCounter++;\n            }\n        }\n        // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n        // consolidating them into `become`, since otherwise we'd create new\n        // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n        function become(newPromise) {\n            resolvedPromise = newPromise;\n            if (Q.longStackSupport && hasStacks) {\n                // Only hold a reference to the new promise if long stacks\n                // are enabled to reduce memory usage\n                promise.source = newPromise;\n            }\n            array_reduce(messages, function(undefined1, message) {\n                Q.nextTick(function() {\n                    newPromise.promiseDispatch.apply(newPromise, message);\n                });\n            }, void 0);\n            messages = void 0;\n            progressListeners = void 0;\n        }\n        deferred.promise = promise;\n        deferred.resolve = function(value) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(Q(value));\n        };\n        deferred.fulfill = function(value) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(fulfill(value));\n        };\n        deferred.reject = function(reason) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(reject(reason));\n        };\n        deferred.notify = function(progress) {\n            if (resolvedPromise) {\n                return;\n            }\n            array_reduce(progressListeners, function(undefined1, progressListener) {\n                Q.nextTick(function() {\n                    progressListener(progress);\n                });\n            }, void 0);\n        };\n        return deferred;\n    }\n    /**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */ defer.prototype.makeNodeResolver = function() {\n        var self1 = this;\n        return function(error, value) {\n            if (error) {\n                self1.reject(error);\n            } else if (arguments.length > 2) {\n                self1.resolve(array_slice(arguments, 1));\n            } else {\n                self1.resolve(value);\n            }\n        };\n    };\n    /**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */ Q.Promise = promise; // ES6\n    Q.promise = promise;\n    function promise(resolver) {\n        if (typeof resolver !== \"function\") {\n            throw new TypeError(\"resolver must be a function.\");\n        }\n        var deferred = defer();\n        try {\n            resolver(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (reason) {\n            deferred.reject(reason);\n        }\n        return deferred.promise;\n    }\n    promise.race = race; // ES6\n    promise.all = all; // ES6\n    promise.reject = reject; // ES6\n    promise.resolve = Q; // ES6\n    // XXX experimental.  This method is a way to denote that a local value is\n    // serializable and should be immediately dispatched to a remote upon request,\n    // instead of passing a reference.\n    Q.passByCopy = function(object) {\n        //freeze(object);\n        //passByCopies.set(object, true);\n        return object;\n    };\n    Promise.prototype.passByCopy = function() {\n        //freeze(object);\n        //passByCopies.set(object, true);\n        return this;\n    };\n    /**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */ Q.join = function(x, y) {\n        return Q(x).join(y);\n    };\n    Promise.prototype.join = function(that) {\n        return Q([\n            this,\n            that\n        ]).spread(function(x, y) {\n            if (x === y) {\n                // TODO: \"===\" should be Object.is or equiv\n                return x;\n            } else {\n                throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n            }\n        });\n    };\n    /**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */ Q.race = race;\n    function race(answerPs) {\n        return promise(function(resolve, reject) {\n            // Switch to this once we can assume at least ES5\n            // answerPs.forEach(function (answerP) {\n            //     Q(answerP).then(resolve, reject);\n            // });\n            // Use this in the meantime\n            for(var i = 0, len = answerPs.length; i < len; i++){\n                Q(answerPs[i]).then(resolve, reject);\n            }\n        });\n    }\n    Promise.prototype.race = function() {\n        return this.then(Q.race);\n    };\n    /**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */ Q.makePromise = Promise;\n    function Promise(descriptor, fallback, inspect) {\n        if (fallback === void 0) {\n            fallback = function(op) {\n                return reject(new Error(\"Promise does not support operation: \" + op));\n            };\n        }\n        if (inspect === void 0) {\n            inspect = function() {\n                return {\n                    state: \"unknown\"\n                };\n            };\n        }\n        var promise = object_create(Promise.prototype);\n        promise.promiseDispatch = function(resolve, op, args) {\n            var result;\n            try {\n                if (descriptor[op]) {\n                    result = descriptor[op].apply(promise, args);\n                } else {\n                    result = fallback.call(promise, op, args);\n                }\n            } catch (exception) {\n                result = reject(exception);\n            }\n            if (resolve) {\n                resolve(result);\n            }\n        };\n        promise.inspect = inspect;\n        // XXX deprecated `valueOf` and `exception` support\n        if (inspect) {\n            var inspected = inspect();\n            if (inspected.state === \"rejected\") {\n                promise.exception = inspected.reason;\n            }\n            promise.valueOf = function() {\n                var inspected = inspect();\n                if (inspected.state === \"pending\" || inspected.state === \"rejected\") {\n                    return promise;\n                }\n                return inspected.value;\n            };\n        }\n        return promise;\n    }\n    Promise.prototype.toString = function() {\n        return \"[object Promise]\";\n    };\n    Promise.prototype.then = function(fulfilled, rejected, progressed) {\n        var self1 = this;\n        var deferred = defer();\n        var done = false; // ensure the untrusted promise makes at most a\n        // single call to one of the callbacks\n        function _fulfilled(value) {\n            try {\n                return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n            } catch (exception) {\n                return reject(exception);\n            }\n        }\n        function _rejected(exception) {\n            if (typeof rejected === \"function\") {\n                makeStackTraceLong(exception, self1);\n                try {\n                    return rejected(exception);\n                } catch (newException) {\n                    return reject(newException);\n                }\n            }\n            return reject(exception);\n        }\n        function _progressed(value) {\n            return typeof progressed === \"function\" ? progressed(value) : value;\n        }\n        Q.nextTick(function() {\n            self1.promiseDispatch(function(value) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                deferred.resolve(_fulfilled(value));\n            }, \"when\", [\n                function(exception) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    deferred.resolve(_rejected(exception));\n                }\n            ]);\n        });\n        // Progress propagator need to be attached in the current tick.\n        self1.promiseDispatch(void 0, \"when\", [\n            void 0,\n            function(value) {\n                var newValue;\n                var threw = false;\n                try {\n                    newValue = _progressed(value);\n                } catch (e) {\n                    threw = true;\n                    if (Q.onerror) {\n                        Q.onerror(e);\n                    } else {\n                        throw e;\n                    }\n                }\n                if (!threw) {\n                    deferred.notify(newValue);\n                }\n            }\n        ]);\n        return deferred.promise;\n    };\n    Q.tap = function(promise, callback) {\n        return Q(promise).tap(callback);\n    };\n    /**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */ Promise.prototype.tap = function(callback) {\n        callback = Q(callback);\n        return this.then(function(value) {\n            return callback.fcall(value).thenResolve(value);\n        });\n    };\n    /**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */ Q.when = when;\n    function when(value, fulfilled, rejected, progressed) {\n        return Q(value).then(fulfilled, rejected, progressed);\n    }\n    Promise.prototype.thenResolve = function(value) {\n        return this.then(function() {\n            return value;\n        });\n    };\n    Q.thenResolve = function(promise, value) {\n        return Q(promise).thenResolve(value);\n    };\n    Promise.prototype.thenReject = function(reason) {\n        return this.then(function() {\n            throw reason;\n        });\n    };\n    Q.thenReject = function(promise, reason) {\n        return Q(promise).thenReject(reason);\n    };\n    /**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If it’s a fulfilled promise, the fulfillment value is nearer.\n * If it’s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */ // XXX should we re-do this?\n    Q.nearer = nearer;\n    function nearer(value) {\n        if (isPromise(value)) {\n            var inspected = value.inspect();\n            if (inspected.state === \"fulfilled\") {\n                return inspected.value;\n            }\n        }\n        return value;\n    }\n    /**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */ Q.isPromise = isPromise;\n    function isPromise(object) {\n        return object instanceof Promise;\n    }\n    Q.isPromiseAlike = isPromiseAlike;\n    function isPromiseAlike(object) {\n        return isObject(object) && typeof object.then === \"function\";\n    }\n    /**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */ Q.isPending = isPending;\n    function isPending(object) {\n        return isPromise(object) && object.inspect().state === \"pending\";\n    }\n    Promise.prototype.isPending = function() {\n        return this.inspect().state === \"pending\";\n    };\n    /**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */ Q.isFulfilled = isFulfilled;\n    function isFulfilled(object) {\n        return !isPromise(object) || object.inspect().state === \"fulfilled\";\n    }\n    Promise.prototype.isFulfilled = function() {\n        return this.inspect().state === \"fulfilled\";\n    };\n    /**\n * @returns whether the given object is a rejected promise.\n */ Q.isRejected = isRejected;\n    function isRejected(object) {\n        return isPromise(object) && object.inspect().state === \"rejected\";\n    }\n    Promise.prototype.isRejected = function() {\n        return this.inspect().state === \"rejected\";\n    };\n    //// BEGIN UNHANDLED REJECTION TRACKING\n    // This promise library consumes exceptions thrown in handlers so they can be\n    // handled by a subsequent promise.  The exceptions get added to this array when\n    // they are created, and removed when they are handled.  Note that in ES6 or\n    // shimmed environments, this would naturally be a `Set`.\n    var unhandledReasons = [];\n    var unhandledRejections = [];\n    var reportedUnhandledRejections = [];\n    var trackUnhandledRejections = true;\n    function resetUnhandledRejections() {\n        unhandledReasons.length = 0;\n        unhandledRejections.length = 0;\n        if (!trackUnhandledRejections) {\n            trackUnhandledRejections = true;\n        }\n    }\n    function trackRejection(promise, reason) {\n        if (!trackUnhandledRejections) {\n            return;\n        }\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function() {\n                if (array_indexOf(unhandledRejections, promise) !== -1) {\n                    process.emit(\"unhandledRejection\", reason, promise);\n                    reportedUnhandledRejections.push(promise);\n                }\n            });\n        }\n        unhandledRejections.push(promise);\n        if (reason && typeof reason.stack !== \"undefined\") {\n            unhandledReasons.push(reason.stack);\n        } else {\n            unhandledReasons.push(\"(no stack) \" + reason);\n        }\n    }\n    function untrackRejection(promise) {\n        if (!trackUnhandledRejections) {\n            return;\n        }\n        var at = array_indexOf(unhandledRejections, promise);\n        if (at !== -1) {\n            if (typeof process === \"object\" && typeof process.emit === \"function\") {\n                Q.nextTick.runAfter(function() {\n                    var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                    if (atReport !== -1) {\n                        process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                        reportedUnhandledRejections.splice(atReport, 1);\n                    }\n                });\n            }\n            unhandledRejections.splice(at, 1);\n            unhandledReasons.splice(at, 1);\n        }\n    }\n    Q.resetUnhandledRejections = resetUnhandledRejections;\n    Q.getUnhandledReasons = function() {\n        // Make a copy so that consumers can't interfere with our internal state.\n        return unhandledReasons.slice();\n    };\n    Q.stopUnhandledRejectionTracking = function() {\n        resetUnhandledRejections();\n        trackUnhandledRejections = false;\n    };\n    resetUnhandledRejections();\n    //// END UNHANDLED REJECTION TRACKING\n    /**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */ Q.reject = reject;\n    function reject(reason) {\n        var rejection = Promise({\n            \"when\": function(rejected) {\n                // note that the error has been handled\n                if (rejected) {\n                    untrackRejection(this);\n                }\n                return rejected ? rejected(reason) : this;\n            }\n        }, function fallback() {\n            return this;\n        }, function inspect() {\n            return {\n                state: \"rejected\",\n                reason: reason\n            };\n        });\n        // Note that the reason has not been handled.\n        trackRejection(rejection, reason);\n        return rejection;\n    }\n    /**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */ Q.fulfill = fulfill;\n    function fulfill(value) {\n        return Promise({\n            \"when\": function() {\n                return value;\n            },\n            \"get\": function(name) {\n                return value[name];\n            },\n            \"set\": function(name, rhs) {\n                value[name] = rhs;\n            },\n            \"delete\": function(name) {\n                delete value[name];\n            },\n            \"post\": function(name, args) {\n                // Mark Miller proposes that post with no name should apply a\n                // promised function.\n                if (name === null || name === void 0) {\n                    return value.apply(void 0, args);\n                } else {\n                    return value[name].apply(value, args);\n                }\n            },\n            \"apply\": function(thisp, args) {\n                return value.apply(thisp, args);\n            },\n            \"keys\": function() {\n                return object_keys(value);\n            }\n        }, void 0, function inspect() {\n            return {\n                state: \"fulfilled\",\n                value: value\n            };\n        });\n    }\n    /**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */ function coerce(promise) {\n        var deferred = defer();\n        Q.nextTick(function() {\n            try {\n                promise.then(deferred.resolve, deferred.reject, deferred.notify);\n            } catch (exception) {\n                deferred.reject(exception);\n            }\n        });\n        return deferred.promise;\n    }\n    /**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */ Q.master = master;\n    function master(object) {\n        return Promise({\n            \"isDef\": function() {}\n        }, function fallback(op, args) {\n            return dispatch(object, op, args);\n        }, function() {\n            return Q(object).inspect();\n        });\n    }\n    /**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */ Q.spread = spread;\n    function spread(value, fulfilled, rejected) {\n        return Q(value).spread(fulfilled, rejected);\n    }\n    Promise.prototype.spread = function(fulfilled, rejected) {\n        return this.all().then(function(array) {\n            return fulfilled.apply(void 0, array);\n        }, rejected);\n    };\n    /**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */ Q.async = async;\n    function async(makeGenerator) {\n        return function() {\n            // when verb is \"send\", arg is a value\n            // when verb is \"throw\", arg is an exception\n            function continuer(verb, arg) {\n                var result;\n                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n                // engine that has a deployed base of browsers that support generators.\n                // However, SM's generators use the Python-inspired semantics of\n                // outdated ES6 drafts.  We would like to support ES6, but we'd also\n                // like to make it possible to use generators in deployed browsers, so\n                // we also support Python-style generators.  At some point we can remove\n                // this block.\n                if (typeof StopIteration === \"undefined\") {\n                    // ES6 Generators\n                    try {\n                        result = generator[verb](arg);\n                    } catch (exception) {\n                        return reject(exception);\n                    }\n                    if (result.done) {\n                        return Q(result.value);\n                    } else {\n                        return when(result.value, callback, errback);\n                    }\n                } else {\n                    // SpiderMonkey Generators\n                    // FIXME: Remove this case when SM does ES6 generators.\n                    try {\n                        result = generator[verb](arg);\n                    } catch (exception) {\n                        if (isStopIteration(exception)) {\n                            return Q(exception.value);\n                        } else {\n                            return reject(exception);\n                        }\n                    }\n                    return when(result, callback, errback);\n                }\n            }\n            var generator = makeGenerator.apply(this, arguments);\n            var callback = continuer.bind(continuer, \"next\");\n            var errback = continuer.bind(continuer, \"throw\");\n            return callback();\n        };\n    }\n    /**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */ Q.spawn = spawn;\n    function spawn(makeGenerator) {\n        Q.done(Q.async(makeGenerator)());\n    }\n    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n    /**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */ Q[\"return\"] = _return;\n    function _return(value) {\n        throw new QReturnValue(value);\n    }\n    /**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */ Q.promised = promised;\n    function promised(callback) {\n        return function() {\n            return spread([\n                this,\n                all(arguments)\n            ], function(self1, args) {\n                return callback.apply(self1, args);\n            });\n        };\n    }\n    /**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */ Q.dispatch = dispatch;\n    function dispatch(object, op, args) {\n        return Q(object).dispatch(op, args);\n    }\n    Promise.prototype.dispatch = function(op, args) {\n        var self1 = this;\n        var deferred = defer();\n        Q.nextTick(function() {\n            self1.promiseDispatch(deferred.resolve, op, args);\n        });\n        return deferred.promise;\n    };\n    /**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */ Q.get = function(object, key) {\n        return Q(object).dispatch(\"get\", [\n            key\n        ]);\n    };\n    Promise.prototype.get = function(key) {\n        return this.dispatch(\"get\", [\n            key\n        ]);\n    };\n    /**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */ Q.set = function(object, key, value) {\n        return Q(object).dispatch(\"set\", [\n            key,\n            value\n        ]);\n    };\n    Promise.prototype.set = function(key, value) {\n        return this.dispatch(\"set\", [\n            key,\n            value\n        ]);\n    };\n    /**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */ Q.del = Q[\"delete\"] = function(object, key) {\n        return Q(object).dispatch(\"delete\", [\n            key\n        ]);\n    };\n    Promise.prototype.del = Promise.prototype[\"delete\"] = function(key) {\n        return this.dispatch(\"delete\", [\n            key\n        ]);\n    };\n    /**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */ // bound locally because it is used by other methods\n    Q.mapply = Q.post = function(object, name, args) {\n        return Q(object).dispatch(\"post\", [\n            name,\n            args\n        ]);\n    };\n    Promise.prototype.mapply = Promise.prototype.post = function(name, args) {\n        return this.dispatch(\"post\", [\n            name,\n            args\n        ]);\n    };\n    /**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */ Q.send = Q.mcall = Q.invoke = function(object, name /*...args*/ ) {\n        return Q(object).dispatch(\"post\", [\n            name,\n            array_slice(arguments, 2)\n        ]);\n    };\n    Promise.prototype.send = Promise.prototype.mcall = Promise.prototype.invoke = function(name /*...args*/ ) {\n        return this.dispatch(\"post\", [\n            name,\n            array_slice(arguments, 1)\n        ]);\n    };\n    /**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */ Q.fapply = function(object, args) {\n        return Q(object).dispatch(\"apply\", [\n            void 0,\n            args\n        ]);\n    };\n    Promise.prototype.fapply = function(args) {\n        return this.dispatch(\"apply\", [\n            void 0,\n            args\n        ]);\n    };\n    /**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */ Q[\"try\"] = Q.fcall = function(object /* ...args*/ ) {\n        return Q(object).dispatch(\"apply\", [\n            void 0,\n            array_slice(arguments, 1)\n        ]);\n    };\n    Promise.prototype.fcall = function() {\n        return this.dispatch(\"apply\", [\n            void 0,\n            array_slice(arguments)\n        ]);\n    };\n    /**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */ Q.fbind = function(object /*...args*/ ) {\n        var promise = Q(object);\n        var args = array_slice(arguments, 1);\n        return function fbound() {\n            return promise.dispatch(\"apply\", [\n                this,\n                args.concat(array_slice(arguments))\n            ]);\n        };\n    };\n    Promise.prototype.fbind = function() {\n        var promise = this;\n        var args = array_slice(arguments);\n        return function fbound() {\n            return promise.dispatch(\"apply\", [\n                this,\n                args.concat(array_slice(arguments))\n            ]);\n        };\n    };\n    /**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */ Q.keys = function(object) {\n        return Q(object).dispatch(\"keys\", []);\n    };\n    Promise.prototype.keys = function() {\n        return this.dispatch(\"keys\", []);\n    };\n    /**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */ // By Mark Miller\n    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n    Q.all = all;\n    function all(promises) {\n        return when(promises, function(promises) {\n            var pendingCount = 0;\n            var deferred = defer();\n            array_reduce(promises, function(undefined1, promise, index) {\n                var snapshot;\n                if (isPromise(promise) && (snapshot = promise.inspect()).state === \"fulfilled\") {\n                    promises[index] = snapshot.value;\n                } else {\n                    ++pendingCount;\n                    when(promise, function(value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    }, deferred.reject, function(progress) {\n                        deferred.notify({\n                            index: index,\n                            value: progress\n                        });\n                    });\n                }\n            }, void 0);\n            if (pendingCount === 0) {\n                deferred.resolve(promises);\n            }\n            return deferred.promise;\n        });\n    }\n    Promise.prototype.all = function() {\n        return all(this);\n    };\n    /**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */ Q.any = any;\n    function any(promises) {\n        if (promises.length === 0) {\n            return Q.resolve();\n        }\n        var deferred = Q.defer();\n        var pendingCount = 0;\n        array_reduce(promises, function(prev, current, index) {\n            var promise = promises[index];\n            pendingCount++;\n            when(promise, onFulfilled, onRejected, onProgress);\n            function onFulfilled(result) {\n                deferred.resolve(result);\n            }\n            function onRejected(err) {\n                pendingCount--;\n                if (pendingCount === 0) {\n                    var rejection = err || new Error(\"\" + err);\n                    rejection.message = \"Q can't get fulfillment value from any promise, all \" + \"promises were rejected. Last error message: \" + rejection.message;\n                    deferred.reject(rejection);\n                }\n            }\n            function onProgress(progress) {\n                deferred.notify({\n                    index: index,\n                    value: progress\n                });\n            }\n        }, undefined);\n        return deferred.promise;\n    }\n    Promise.prototype.any = function() {\n        return any(this);\n    };\n    /**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */ Q.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n    function allResolved(promises) {\n        return when(promises, function(promises) {\n            promises = array_map(promises, Q);\n            return when(all(array_map(promises, function(promise) {\n                return when(promise, noop, noop);\n            })), function() {\n                return promises;\n            });\n        });\n    }\n    Promise.prototype.allResolved = function() {\n        return allResolved(this);\n    };\n    /**\n * @see Promise#allSettled\n */ Q.allSettled = allSettled;\n    function allSettled(promises) {\n        return Q(promises).allSettled();\n    }\n    /**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */ Promise.prototype.allSettled = function() {\n        return this.then(function(promises) {\n            return all(array_map(promises, function(promise) {\n                promise = Q(promise);\n                function regardless() {\n                    return promise.inspect();\n                }\n                return promise.then(regardless, regardless);\n            }));\n        });\n    };\n    /**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */ Q.fail = Q[\"catch\"] = function(object, rejected) {\n        return Q(object).then(void 0, rejected);\n    };\n    Promise.prototype.fail = Promise.prototype[\"catch\"] = function(rejected) {\n        return this.then(void 0, rejected);\n    };\n    /**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */ Q.progress = progress;\n    function progress(object, progressed) {\n        return Q(object).then(void 0, void 0, progressed);\n    }\n    Promise.prototype.progress = function(progressed) {\n        return this.then(void 0, void 0, progressed);\n    };\n    /**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */ Q.fin = Q[\"finally\"] = function(object, callback) {\n        return Q(object)[\"finally\"](callback);\n    };\n    Promise.prototype.fin = Promise.prototype[\"finally\"] = function(callback) {\n        if (!callback || typeof callback.apply !== \"function\") {\n            throw new Error(\"Q can't apply finally callback\");\n        }\n        callback = Q(callback);\n        return this.then(function(value) {\n            return callback.fcall().then(function() {\n                return value;\n            });\n        }, function(reason) {\n            // TODO attempt to recycle the rejection with \"this\".\n            return callback.fcall().then(function() {\n                throw reason;\n            });\n        });\n    };\n    /**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */ Q.done = function(object, fulfilled, rejected, progress) {\n        return Q(object).done(fulfilled, rejected, progress);\n    };\n    Promise.prototype.done = function(fulfilled, rejected, progress) {\n        var onUnhandledError = function(error) {\n            // forward to a future turn so that ``when``\n            // does not catch it and turn it into a rejection.\n            Q.nextTick(function() {\n                makeStackTraceLong(error, promise);\n                if (Q.onerror) {\n                    Q.onerror(error);\n                } else {\n                    throw error;\n                }\n            });\n        };\n        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;\n        if (typeof process === \"object\" && process && process.domain) {\n            onUnhandledError = process.domain.bind(onUnhandledError);\n        }\n        promise.then(void 0, onUnhandledError);\n    };\n    /**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */ Q.timeout = function(object, ms, error) {\n        return Q(object).timeout(ms, error);\n    };\n    Promise.prototype.timeout = function(ms, error) {\n        var deferred = defer();\n        var timeoutId = setTimeout(function() {\n            if (!error || \"string\" === typeof error) {\n                error = new Error(error || \"Timed out after \" + ms + \" ms\");\n                error.code = \"ETIMEDOUT\";\n            }\n            deferred.reject(error);\n        }, ms);\n        this.then(function(value) {\n            clearTimeout(timeoutId);\n            deferred.resolve(value);\n        }, function(exception) {\n            clearTimeout(timeoutId);\n            deferred.reject(exception);\n        }, deferred.notify);\n        return deferred.promise;\n    };\n    /**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */ Q.delay = function(object, timeout) {\n        if (timeout === void 0) {\n            timeout = object;\n            object = void 0;\n        }\n        return Q(object).delay(timeout);\n    };\n    Promise.prototype.delay = function(timeout) {\n        return this.then(function(value) {\n            var deferred = defer();\n            setTimeout(function() {\n                deferred.resolve(value);\n            }, timeout);\n            return deferred.promise;\n        });\n    };\n    /**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */ Q.nfapply = function(callback, args) {\n        return Q(callback).nfapply(args);\n    };\n    Promise.prototype.nfapply = function(args) {\n        var deferred = defer();\n        var nodeArgs = array_slice(args);\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */ Q.nfcall = function(callback /*...args*/ ) {\n        var args = array_slice(arguments, 1);\n        return Q(callback).nfapply(args);\n    };\n    Promise.prototype.nfcall = function() {\n        var nodeArgs = array_slice(arguments);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */ Q.nfbind = Q.denodeify = function(callback /*...args*/ ) {\n        if (callback === undefined) {\n            throw new Error(\"Q can't wrap an undefined function\");\n        }\n        var baseArgs = array_slice(arguments, 1);\n        return function() {\n            var nodeArgs = baseArgs.concat(array_slice(arguments));\n            var deferred = defer();\n            nodeArgs.push(deferred.makeNodeResolver());\n            Q(callback).fapply(nodeArgs).fail(deferred.reject);\n            return deferred.promise;\n        };\n    };\n    Promise.prototype.nfbind = Promise.prototype.denodeify = function() {\n        var args = array_slice(arguments);\n        args.unshift(this);\n        return Q.denodeify.apply(void 0, args);\n    };\n    Q.nbind = function(callback, thisp /*...args*/ ) {\n        var baseArgs = array_slice(arguments, 2);\n        return function() {\n            var nodeArgs = baseArgs.concat(array_slice(arguments));\n            var deferred = defer();\n            nodeArgs.push(deferred.makeNodeResolver());\n            function bound() {\n                return callback.apply(thisp, arguments);\n            }\n            Q(bound).fapply(nodeArgs).fail(deferred.reject);\n            return deferred.promise;\n        };\n    };\n    Promise.prototype.nbind = function() {\n        var args = array_slice(arguments, 0);\n        args.unshift(this);\n        return Q.nbind.apply(void 0, args);\n    };\n    /**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */ Q.nmapply = Q.npost = function(object, name, args) {\n        return Q(object).npost(name, args);\n    };\n    Promise.prototype.nmapply = Promise.prototype.npost = function(name, args) {\n        var nodeArgs = array_slice(args || []);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */ Q.nsend = Q.nmcall = Q.ninvoke = function(object, name /*...args*/ ) {\n        var nodeArgs = array_slice(arguments, 2);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(object).dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    Promise.prototype.nsend = Promise.prototype.nmcall = Promise.prototype.ninvoke = function(name /*...args*/ ) {\n        var nodeArgs = array_slice(arguments, 1);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */ Q.nodeify = nodeify;\n    function nodeify(object, nodeback) {\n        return Q(object).nodeify(nodeback);\n    }\n    Promise.prototype.nodeify = function(nodeback) {\n        if (nodeback) {\n            this.then(function(value) {\n                Q.nextTick(function() {\n                    nodeback(null, value);\n                });\n            }, function(error) {\n                Q.nextTick(function() {\n                    nodeback(error);\n                });\n            });\n        } else {\n            return this;\n        }\n    };\n    Q.noConflict = function() {\n        throw new Error(\"Q.noConflict only works when Q is used as a global\");\n    };\n    // All code before this point will be filtered from stack traces.\n    var qEndingLine = captureLine();\n    return Q;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUTtZQUFDeEY7WUFBTXdJO1NBQVMsRUFBRVYsSUFBSSxDQUFDN0csU0FBU2UsTUFBTTtRQUM1RCxPQUFPZixTQUFTaEQsT0FBTztJQUMzQjtJQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNEekYsRUFBRTRRLE9BQU8sR0FBR0E7SUFDWixTQUFTQSxRQUFROUwsTUFBTSxFQUFFK0wsUUFBUTtRQUM3QixPQUFPN1EsRUFBRThFLFFBQVE4TCxPQUFPLENBQUNDO0lBQzdCO0lBRUFqSixRQUFRNUUsU0FBUyxDQUFDNE4sT0FBTyxHQUFHLFNBQVVDLFFBQVE7UUFDMUMsSUFBSUEsVUFBVTtZQUNWLElBQUksQ0FBQ3JHLElBQUksQ0FBQyxTQUFVOUcsS0FBSztnQkFDckIxRCxFQUFFVSxRQUFRLENBQUM7b0JBQ1BtUSxTQUFTLE1BQU1uTjtnQkFDbkI7WUFDSixHQUFHLFNBQVU4QixLQUFLO2dCQUNkeEYsRUFBRVUsUUFBUSxDQUFDO29CQUNQbVEsU0FBU3JMO2dCQUNiO1lBQ0o7UUFDSixPQUFPO1lBQ0gsT0FBTyxJQUFJO1FBQ2Y7SUFDSjtJQUVBeEYsRUFBRUMsVUFBVSxHQUFHO1FBQ1gsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBRUEsaUVBQWlFO0lBQ2pFLElBQUltSCxjQUFjOUc7SUFFbEIsT0FBT1A7QUFFUCIsInNvdXJjZXMiOlsid2VicGFjazovL2ltYWdpbmlmeS8uL25vZGVfbW9kdWxlcy9xL3EuanM/Y2UxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxNyBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9ibG9iL3YxL0xJQ0VOU0VcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IFR5bGVyIENsb3NlXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDA5IFR5bGVyIENsb3NlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIFggbGljZW5zZSBmb3VuZFxuICogYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5odG1sXG4gKiBGb3JrZWQgYXQgcmVmX3NlbmQuanMgdmVyc2lvbjogMjAwOS0wNS0xMVxuICpcbiAqIFdpdGggcGFydHMgYnkgTWFyayBNaWxsZXJcbiAqIENvcHlyaWdodCAoQykgMjAxMSBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFRoaXMgZmlsZSB3aWxsIGZ1bmN0aW9uIHByb3Blcmx5IGFzIGEgPHNjcmlwdD4gdGFnLCBvciBhIG1vZHVsZVxuICAgIC8vIHVzaW5nIENvbW1vbkpTIGFuZCBOb2RlSlMgb3IgUmVxdWlyZUpTIG1vZHVsZSBmb3JtYXRzLiAgSW5cbiAgICAvLyBDb21tb24vTm9kZS9SZXF1aXJlSlMsIHRoZSBtb2R1bGUgZXhwb3J0cyB0aGUgUSBBUEkgYW5kIHdoZW5cbiAgICAvLyBleGVjdXRlZCBhcyBhIHNpbXBsZSA8c2NyaXB0PiwgaXQgY3JlYXRlcyBhIFEgZ2xvYmFsIGluc3RlYWQuXG5cbiAgICAvLyBNb250YWdlIFJlcXVpcmVcbiAgICBpZiAodHlwZW9mIGJvb3RzdHJhcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGJvb3RzdHJhcChcInByb21pc2VcIiwgZGVmaW5pdGlvbik7XG5cbiAgICAvLyBDb21tb25KU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcblxuICAgIC8vIFJlcXVpcmVKU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuXG4gICAgLy8gU0VTIChTZWN1cmUgRWNtYVNjcmlwdClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKCFzZXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VzLm1ha2VRID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuXG4gICAgLy8gPHNjcmlwdD5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gUHJlZmVyIHdpbmRvdyBvdmVyIHNlbGYgZm9yIGFkZC1vbiBzY3JpcHRzLiBVc2Ugc2VsZiBmb3JcbiAgICAgICAgLy8gbm9uLXdpbmRvd2VkIGNvbnRleHRzLlxuICAgICAgICB2YXIgZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBgd2luZG93YCBvYmplY3QsIHNhdmUgdGhlIHByZXZpb3VzIFEgZ2xvYmFsXG4gICAgICAgIC8vIGFuZCBpbml0aWFsaXplIFEgYXMgYSBnbG9iYWwuXG4gICAgICAgIHZhciBwcmV2aW91c1EgPSBnbG9iYWwuUTtcbiAgICAgICAgZ2xvYmFsLlEgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAgICAgLy8gQWRkIGEgbm9Db25mbGljdCBmdW5jdGlvbiBzbyBRIGNhbiBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICAgIC8vIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgIGdsb2JhbC5RLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnbG9iYWwuUSA9IHByZXZpb3VzUTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCB3YXMgbm90IGFudGljaXBhdGVkIGJ5IFEuIFBsZWFzZSBmaWxlIGEgYnVnLlwiKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuICAgIC8vIHF1ZXVlIGZvciBsYXRlIHRhc2tzLCB1c2VkIGJ5IHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmdcbiAgICB2YXIgbGF0ZXJRdWV1ZSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICB2YXIgdGFzaywgZG9tYWluO1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkLmRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pO1xuXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxhdGVyUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXNrID0gbGF0ZXJRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBydW5zIGEgc2luZ2xlIGZ1bmN0aW9uIGluIHRoZSBhc3luYyBxdWV1ZVxuICAgIGZ1bmN0aW9uIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRpbnVhdGlvbiBpZiB0aGUgdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHN1cHByZXNzZWRcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHRUaWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHByb2Nlc3MudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgICAgICAvLyBFbnN1cmUgUSBpcyBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudCwgd2l0aCBhIGBwcm9jZXNzLm5leHRUaWNrYC5cbiAgICAgICAgLy8gVG8gc2VlIHRocm91Z2ggZmFrZSBOb2RlIGVudmlyb25tZW50czpcbiAgICAgICAgLy8gKiBNb2NoYSB0ZXN0IHJ1bm5lciAtIGV4cG9zZXMgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgXG4gICAgICAgIC8vICogQnJvd3NlcmlmeSAtIGV4cG9zZXMgYSBgcHJvY2Vzcy5uZXhUaWNrYCBmdW5jdGlvbiB0aGF0IHVzZXNcbiAgICAgICAgLy8gICBgc2V0VGltZW91dGAuIEluIHRoaXMgY2FzZSBgc2V0SW1tZWRpYXRlYCBpcyBwcmVmZXJyZWQgYmVjYXVzZVxuICAgICAgICAvLyAgICBpdCBpcyBmYXN0ZXIuIEJyb3dzZXJpZnkncyBgcHJvY2Vzcy50b1N0cmluZygpYCB5aWVsZHNcbiAgICAgICAgLy8gICBcIltvYmplY3QgT2JqZWN0XVwiLCB3aGlsZSBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudFxuICAgICAgICAvLyAgIGBwcm9jZXNzLnRvU3RyaW5nKClgIHlpZWxkcyBcIltvYmplY3QgcHJvY2Vzc11cIi5cbiAgICAgICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgU2FmYXJpIFZlcnNpb24gNi4wLjUgKDg1MzYuMzAuMSkgaW50ZXJtaXR0ZW50bHkgY2Fubm90IGNyZWF0ZVxuICAgICAgICAvLyB3b3JraW5nIG1lc3NhZ2UgcG9ydHMgdGhlIGZpcnN0IHRpbWUgYSBwYWdlIGxvYWRzLlxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gcmVxdWVzdFBvcnRUaWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0UG9ydFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIHVzZSBpdC5cbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICByZXF1ZXN0UG9ydFRpY2soKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBicm93c2Vyc1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBydW5zIGEgdGFzayBhZnRlciBhbGwgb3RoZXIgdGFza3MgaGF2ZSBiZWVuIHJ1blxuICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciB1bmhhbmRsZWQgcmVqZWN0aW9uIHRyYWNraW5nIHRoYXQgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgYWxsIGB0aGVuYGQgdGFza3MgaGF2ZSBiZWVuIHJ1bi5cbiAgICBuZXh0VGljay5ydW5BZnRlciA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIGxhdGVyUXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5leHRUaWNrO1xufSkoKTtcblxuLy8gQXR0ZW1wdCB0byBtYWtlIGdlbmVyaWNzIHNhZmUgaW4gdGhlIGZhY2Ugb2YgZG93bnN0cmVhbVxuLy8gbW9kaWZpY2F0aW9ucy5cbi8vIFRoZXJlIGlzIG5vIHNpdHVhdGlvbiB3aGVyZSB0aGlzIGlzIG5lY2Vzc2FyeS5cbi8vIElmIHlvdSBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLCB0aGVzZSBwcmltb3JkaWFscyBuZWVkIHRvIGJlXG4vLyBkZWVwbHkgZnJvemVuIGFueXdheSwgYW5kIGlmIHlvdSBkb27igJl0IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsXG4vLyB0aGlzIGlzIGp1c3QgcGxhaW4gcGFyYW5vaWQuXG4vLyBIb3dldmVyLCB0aGlzICoqbWlnaHQqKiBoYXZlIHRoZSBuaWNlIHNpZGUtZWZmZWN0IG9mIHJlZHVjaW5nIHRoZSBzaXplIG9mXG4vLyB0aGUgbWluaWZpZWQgY29kZSBieSByZWR1Y2luZyB4LmNhbGwoKSB0byBtZXJlbHkgeCgpXG4vLyBTZWUgTWFyayBNaWxsZXLigJlzIGV4cGxhbmF0aW9uIG9mIHdoYXQgdGhpcyBkb2VzLlxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9Y29udmVudGlvbnM6c2FmZV9tZXRhX3Byb2dyYW1taW5nXG52YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuLy8gVGhpcyBpcyBlcXVpdmFsZW50LCBidXQgc2xvd2VyOlxuLy8gdW5jdXJyeVRoaXMgPSBGdW5jdGlvbl9iaW5kLmJpbmQoRnVuY3Rpb25fYmluZC5jYWxsKTtcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3VuY3Vycnl0aGlzXG5cbnZhciBhcnJheV9zbGljZSA9IHVuY3VycnlUaGlzKEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG5cbnZhciBhcnJheV9yZWR1Y2UgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzaXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBjb25jZXJuaW5nIHRoZSBpbml0aWFsIHZhbHVlLCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBzZWVrIHRvIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYXJyYXksIGFjY291bnRpbmdcbiAgICAgICAgICAgIC8vIGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCBpcyBpcyBhIHNwYXJzZSBhcnJheVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2lzID0gdGhpc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdWNlXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGFycmF5IGlzIHNwYXJzZVxuICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBiYXNpcyA9IGNhbGxiYWNrKGJhc2lzLCB0aGlzW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNpcztcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfaW5kZXhPZiA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBub3QgYSB2ZXJ5IGdvb2Qgc2hpbSwgYnV0IGdvb2QgZW5vdWdoIGZvciBvdXIgb25lIHVzZSBvZiBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfbWFwID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLm1hcCB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbGxlY3QgPSBbXTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHNlbGYsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc3AsIHZhbHVlLCBpbmRleCwgc2VsZikpO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICByZXR1cm4gY29sbGVjdDtcbiAgICB9XG4pO1xuXG52YXIgb2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICAgIGZ1bmN0aW9uIFR5cGUoKSB7IH1cbiAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3IFR5cGUoKTtcbn07XG5cbnZhciBvYmplY3RfZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgIG9ialtwcm9wXSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBvYmplY3RfaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxudmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0X2hhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgb2JqZWN0X3RvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBPYmplY3QodmFsdWUpO1xufVxuXG4vLyBnZW5lcmF0b3IgcmVsYXRlZCBzaGltc1xuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgZnVuY3Rpb24gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuZnVuY3Rpb24gaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICAgIG9iamVjdF90b1N0cmluZyhleGNlcHRpb24pID09PSBcIltvYmplY3QgU3RvcEl0ZXJhdGlvbl1cIiB8fFxuICAgICAgICBleGNlcHRpb24gaW5zdGFuY2VvZiBRUmV0dXJuVmFsdWVcbiAgICApO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaGVscGVyIGFuZCBRLnJldHVybiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpblxuLy8gU3BpZGVyTW9ua2V5LlxudmFyIFFSZXR1cm5WYWx1ZTtcbmlmICh0eXBlb2YgUmV0dXJuVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBSZXR1cm5WYWx1ZTtcbn0gZWxzZSB7XG4gICAgUVJldHVyblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xufVxuXG4vLyBsb25nIHN0YWNrIHRyYWNlc1xuXG52YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSBcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCI7XG5cbmZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFFcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBwcm9taXNlYC4gU2VlICM1Ny5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIHByb21pc2Uuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgIGVycm9yLnN0YWNrXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjayAmJiAoIWVycm9yLl9fbWluaW11bVN0YWNrQ291bnRlcl9fIHx8IGVycm9yLl9fbWluaW11bVN0YWNrQ291bnRlcl9fID4gcC5zdGFja0NvdW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0X2RlZmluZVByb3BlcnR5KGVycm9yLCBcIl9fbWluaW11bVN0YWNrQ291bnRlcl9fXCIsIHt2YWx1ZTogcC5zdGFja0NvdW50ZXIsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZmlsdGVyU3RhY2tTdHJpbmcoY29uY2F0ZWRTdGFja3MpO1xuICAgICAgICBvYmplY3RfZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwic3RhY2tcIiwge3ZhbHVlOiBzdGFjaywgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGNvdW50ZXIgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHN0b3BwaW5nIHBvaW50IGZvciBidWlsZGluZ1xuICogbG9uZyBzdGFjayB0cmFjZXMuIEluIG1ha2VTdGFja1RyYWNlTG9uZyB3ZSB3YWxrIGJhY2t3YXJkcyB0aHJvdWdoXG4gKiB0aGUgbGlua2VkIGxpc3Qgb2YgcHJvbWlzZXMsIG9ubHkgc3RhY2tzIHdoaWNoIHdlcmUgY3JlYXRlZCBiZWZvcmVcbiAqIHRoZSByZWplY3Rpb24gYXJlIGNvbmNhdGVuYXRlZC5cbiAqL1xudmFyIGxvbmdTdGFja0NvdW50ZXIgPSAxO1xuXG4vLyBlbmFibGUgbG9uZyBzdGFja3MgaWYgUV9ERUJVRyBpcyBzZXRcbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LlFfREVCVUcpIHtcbiAgICBRLmxvbmdTdGFja1N1cHBvcnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSB7cHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0fSBvYmplY3QuXG4gKlxuICogYHJlc29sdmVgIGlzIGEgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggYSBtb3JlIHJlc29sdmVkIHZhbHVlIGZvciB0aGVcbiAqIHByb21pc2UuIFRvIGZ1bGZpbGwgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhbnkgdmFsdWUgdGhhdCBpc1xuICogbm90IGEgdGhlbmFibGUuIFRvIHJlamVjdCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGEgcmVqZWN0ZWRcbiAqIHRoZW5hYmxlLCBvciBpbnZva2UgYHJlamVjdGAgd2l0aCB0aGUgcmVhc29uIGRpcmVjdGx5LiBUbyByZXNvbHZlIHRoZVxuICogcHJvbWlzZSB0byBhbm90aGVyIHRoZW5hYmxlLCB0aHVzIHB1dHRpbmcgaXQgaW4gdGhlIHNhbWUgc3RhdGUsIGludm9rZVxuICogYHJlc29sdmVgIHdpdGggdGhhdCBvdGhlciB0aGVuYWJsZS5cbiAqL1xuUS5kZWZlciA9IGRlZmVyO1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgLy8gaWYgXCJtZXNzYWdlc1wiIGlzIGFuIFwiQXJyYXlcIiwgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgcHJvbWlzZSBoYXMgbm90IHlldFxuICAgIC8vIGJlZW4gcmVzb2x2ZWQuICBJZiBpdCBpcyBcInVuZGVmaW5lZFwiLCBpdCBoYXMgYmVlbiByZXNvbHZlZC4gIEVhY2hcbiAgICAvLyBlbGVtZW50IG9mIHRoZSBtZXNzYWdlcyBhcnJheSBpcyBpdHNlbGYgYW4gYXJyYXkgb2YgY29tcGxldGUgYXJndW1lbnRzIHRvXG4gICAgLy8gZm9yd2FyZCB0byB0aGUgcmVzb2x2ZWQgcHJvbWlzZS4gIFdlIGNvZXJjZSB0aGUgcmVzb2x1dGlvbiB2YWx1ZSB0byBhXG4gICAgLy8gcHJvbWlzZSB1c2luZyB0aGUgYHJlc29sdmVgIGZ1bmN0aW9uIGJlY2F1c2UgaXQgaGFuZGxlcyBib3RoIGZ1bGx5XG4gICAgLy8gbm9uLXRoZW5hYmxlIHZhbHVlcyBhbmQgb3RoZXIgdGhlbmFibGVzIGdyYWNlZnVsbHkuXG4gICAgdmFyIG1lc3NhZ2VzID0gW10sIHByb2dyZXNzTGlzdGVuZXJzID0gW10sIHJlc29sdmVkUHJvbWlzZTtcblxuICAgIHZhciBkZWZlcnJlZCA9IG9iamVjdF9jcmVhdGUoZGVmZXIucHJvdG90eXBlKTtcbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIG9wZXJhbmRzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKG9wID09PSBcIndoZW5cIiAmJiBvcGVyYW5kc1sxXSkgeyAvLyBwcm9ncmVzcyBvcGVyYW5kXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KHJlc29sdmVkUHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZFxuICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVhcmVyVmFsdWUgPSBuZWFyZXIocmVzb2x2ZWRQcm9taXNlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShuZWFyZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5lYXJlclZhbHVlOyAvLyBzaG9ydGVuIGNoYWluXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlclZhbHVlO1xuICAgIH07XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJwZW5kaW5nXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQcm9taXNlLmluc3BlY3QoKTtcbiAgICB9O1xuXG4gICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBkb24ndCB0cnkgdG8gdXNlIGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAgb3IgdHJhbnNmZXIgdGhlXG4gICAgICAgICAgICAvLyBhY2Nlc3NvciBhcm91bmQ7IHRoYXQgY2F1c2VzIG1lbW9yeSBsZWFrcyBhcyBwZXIgR0gtMTExLiBKdXN0XG4gICAgICAgICAgICAvLyByZWlmeSB0aGUgc3RhY2sgdHJhY2UgYXMgYSBzdHJpbmcgQVNBUC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBjdXQgb2ZmIHRoZSBmaXJzdCBsaW5lOyBpdCdzIGFsd2F5cyBqdXN0XG4gICAgICAgICAgICAvLyBcIltvYmplY3QgUHJvbWlzZV1cXG5cIiwgYXMgcGVyIHRoZSBgdG9TdHJpbmdgLlxuICAgICAgICAgICAgcHJvbWlzZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyaW5nKGUuc3RhY2suaW5kZXhPZihcIlxcblwiKSArIDEpO1xuICAgICAgICAgICAgcHJvbWlzZS5zdGFja0NvdW50ZXIgPSBsb25nU3RhY2tDb3VudGVyKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcblxuICAgICAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICAgICAgLy8gT25seSBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBuZXcgcHJvbWlzZSBpZiBsb25nIHN0YWNrc1xuICAgICAgICAgICAgLy8gYXJlIGVuYWJsZWQgdG8gcmVkdWNlIG1lbW9yeSB1c2FnZVxuICAgICAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKG1lc3NhZ2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShuZXdQcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuXG4gICAgICAgIG1lc3NhZ2VzID0gdm9pZCAwO1xuICAgICAgICBwcm9ncmVzc0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICBkZWZlcnJlZC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShRKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGRlZmVycmVkLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKGZ1bGZpbGwodmFsdWUpKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKHJlamVjdChyZWFzb24pKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UocHJvZ3Jlc3NMaXN0ZW5lcnMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb2dyZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIGRlZmVycmVkXG4gKiBwcm9taXNlLlxuICogQHJldHVybnMgYSBub2RlYmFja1xuICovXG5kZWZlci5wcm90b3R5cGUubWFrZU5vZGVSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZShhcnJheV9zbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gcmVzb2x2ZXIge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub3RoaW5nIGFuZCBhY2NlcHRzXG4gKiB0aGUgcmVzb2x2ZSwgcmVqZWN0LCBhbmQgbm90aWZ5IGZ1bmN0aW9ucyBmb3IgYSBkZWZlcnJlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IG1heSBiZSByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiByZXNvbHZlIGFuZCByZWplY3RcbiAqIGZ1bmN0aW9ucywgb3IgcmVqZWN0ZWQgYnkgYSB0aHJvd24gZXhjZXB0aW9uIGluIHJlc29sdmVyXG4gKi9cblEuUHJvbWlzZSA9IHByb21pc2U7IC8vIEVTNlxuUS5wcm9taXNlID0gcHJvbWlzZTtcbmZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbnByb21pc2UucmFjZSA9IHJhY2U7IC8vIEVTNlxucHJvbWlzZS5hbGwgPSBhbGw7IC8vIEVTNlxucHJvbWlzZS5yZWplY3QgPSByZWplY3Q7IC8vIEVTNlxucHJvbWlzZS5yZXNvbHZlID0gUTsgLy8gRVM2XG5cbi8vIFhYWCBleHBlcmltZW50YWwuICBUaGlzIG1ldGhvZCBpcyBhIHdheSB0byBkZW5vdGUgdGhhdCBhIGxvY2FsIHZhbHVlIGlzXG4vLyBzZXJpYWxpemFibGUgYW5kIHNob3VsZCBiZSBpbW1lZGlhdGVseSBkaXNwYXRjaGVkIHRvIGEgcmVtb3RlIHVwb24gcmVxdWVzdCxcbi8vIGluc3RlYWQgb2YgcGFzc2luZyBhIHJlZmVyZW5jZS5cblEucGFzc0J5Q29weSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIElmIHR3byBwcm9taXNlcyBldmVudHVhbGx5IGZ1bGZpbGwgdG8gdGhlIHNhbWUgdmFsdWUsIHByb21pc2VzIHRoYXQgdmFsdWUsXG4gKiBidXQgb3RoZXJ3aXNlIHJlamVjdHMuXG4gKiBAcGFyYW0geCB7QW55Kn1cbiAqIEBwYXJhbSB5IHtBbnkqfVxuICogQHJldHVybnMge0FueSp9IGEgcHJvbWlzZSBmb3IgeCBhbmQgeSBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYnV0IGEgcmVqZWN0aW9uXG4gKiBvdGhlcndpc2UuXG4gKlxuICovXG5RLmpvaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBRKHgpLmpvaW4oeSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICByZXR1cm4gUShbdGhpcywgdGhhdF0pLnNwcmVhZChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gVE9ETzogXCI9PT1cIiBzaG91bGQgYmUgT2JqZWN0LmlzIG9yIGVxdWl2XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3Qgam9pbjogbm90IHRoZSBzYW1lOiBcIiArIHggKyBcIiBcIiArIHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIHNldHRsZWQuXG4gKiBAcGFyYW0gYW5zd2VycyB7QXJyYXlbQW55Kl19IHByb21pc2VzIHRvIHJhY2VcbiAqIEByZXR1cm5zIHtBbnkqfSB0aGUgZmlyc3QgcHJvbWlzZSB0byBiZSBzZXR0bGVkXG4gKi9cblEucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGFuc3dlclBzKSB7XG4gICAgcmV0dXJuIHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24gKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgZG9uZSA9IGZhbHNlOyAgIC8vIGVuc3VyZSB0aGUgdW50cnVzdGVkIHByb21pc2UgbWFrZXMgYXQgbW9zdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2FsbCB0byBvbmUgb2YgdGhlIGNhbGxiYWNrc1xuXG4gICAgZnVuY3Rpb24gX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0ZWQoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGV4Y2VwdGlvbiwgc2VsZik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZChleGNlcHRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFeGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcHJvZ3Jlc3NlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2dyZXNzZWQgPT09IFwiZnVuY3Rpb25cIiA/IHByb2dyZXNzZWQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5RLnRhcCA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRhcChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdvcmtzIGFsbW9zdCBsaWtlIFwiZmluYWxseVwiLCBidXQgbm90IGNhbGxlZCBmb3IgcmVqZWN0aW9ucy5cbiAqIE9yaWdpbmFsIHJlc29sdXRpb24gdmFsdWUgaXMgcGFzc2VkIHRocm91Z2ggY2FsbGJhY2sgdW5hZmZlY3RlZC5cbiAqIENhbGxiYWNrIG1heSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBhd2FpdGVkIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7US5Qcm9taXNlfVxuICogQGV4YW1wbGVcbiAqIGRvU29tZXRoaW5nKClcbiAqICAgLnRoZW4oLi4uKVxuICogICAudGFwKGNvbnNvbGUubG9nKVxuICogICAudGhlbiguLi4pO1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKHZhbHVlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuXG5RLmlzUHJvbWlzZUFsaWtlID0gaXNQcm9taXNlQWxpa2U7XG5mdW5jdGlvbiBpc1Byb21pc2VBbGlrZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwZW5kaW5nIHByb21pc2UsIG1lYW5pbmcgbm90XG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gKi9cblEuaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xuZnVuY3Rpb24gaXNQZW5kaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbHVlIG9yIGZ1bGZpbGxlZFxuICogcHJvbWlzZS5cbiAqL1xuUS5pc0Z1bGZpbGxlZCA9IGlzRnVsZmlsbGVkO1xuZnVuY3Rpb24gaXNGdWxmaWxsZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuICFpc1Byb21pc2Uob2JqZWN0KSB8fCBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cblEuaXNSZWplY3RlZCA9IGlzUmVqZWN0ZWQ7XG5mdW5jdGlvbiBpc1JlamVjdGVkKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59O1xuXG4vLy8vIEJFR0lOIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLy8gVGhpcyBwcm9taXNlIGxpYnJhcnkgY29uc3VtZXMgZXhjZXB0aW9ucyB0aHJvd24gaW4gaGFuZGxlcnMgc28gdGhleSBjYW4gYmVcbi8vIGhhbmRsZWQgYnkgYSBzdWJzZXF1ZW50IHByb21pc2UuICBUaGUgZXhjZXB0aW9ucyBnZXQgYWRkZWQgdG8gdGhpcyBhcnJheSB3aGVuXG4vLyB0aGV5IGFyZSBjcmVhdGVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZXkgYXJlIGhhbmRsZWQuICBOb3RlIHRoYXQgaW4gRVM2IG9yXG4vLyBzaGltbWVkIGVudmlyb25tZW50cywgdGhpcyB3b3VsZCBuYXR1cmFsbHkgYmUgYSBgU2V0YC5cbnZhciB1bmhhbmRsZWRSZWFzb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhcnJheV9pbmRleE9mKHVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuaGFuZGxlZFJlamVjdGlvblwiLCByZWFzb24sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXRSZXBvcnQgPSBhcnJheV9pbmRleE9mKHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0UmVwb3J0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJyZWplY3Rpb25IYW5kbGVkXCIsIHVuaGFuZGxlZFJlYXNvbnNbYXRdLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdFJlcG9ydCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoYXQsIDEpO1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnNwbGljZShhdCwgMSk7XG4gICAgfVxufVxuXG5RLnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucyA9IHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucztcblxuUS5nZXRVbmhhbmRsZWRSZWFzb25zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIHRoYXQgY29uc3VtZXJzIGNhbid0IGludGVyZmVyZSB3aXRoIG91ciBpbnRlcm5hbCBzdGF0ZS5cbiAgICByZXR1cm4gdW5oYW5kbGVkUmVhc29ucy5zbGljZSgpO1xufTtcblxuUS5zdG9wVW5oYW5kbGVkUmVqZWN0aW9uVHJhY2tpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gZmFsc2U7XG59O1xuXG5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcblxuLy8vLyBFTkQgVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWplY3RlZCBwcm9taXNlLlxuICogQHBhcmFtIHJlYXNvbiB2YWx1ZSBkZXNjcmliaW5nIHRoZSBmYWlsdXJlXG4gKi9cblEucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHZhciByZWplY3Rpb24gPSBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoZSBlcnJvciBoYXMgYmVlbiBoYW5kbGVkXG4gICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1bnRyYWNrUmVqZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQocmVhc29uKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGUgcmVhc29uIGhhcyBub3QgYmVlbiBoYW5kbGVkLlxuICAgIHRyYWNrUmVqZWN0aW9uKHJlamVjdGlvbiwgcmVhc29uKTtcblxuICAgIHJldHVybiByZWplY3Rpb247XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZ1bGZpbGxlZCBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2VcbiAqL1xuUS5mdWxmaWxsID0gZnVsZmlsbDtcbmZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2V0XCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwic2V0XCI6IGZ1bmN0aW9uIChuYW1lLCByaHMpIHtcbiAgICAgICAgICAgIHZhbHVlW25hbWVdID0gcmhzO1xuICAgICAgICB9LFxuICAgICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInBvc3RcIjogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgTWlsbGVyIHByb3Bvc2VzIHRoYXQgcG9zdCB3aXRoIG5vIG5hbWUgc2hvdWxkIGFwcGx5IGFcbiAgICAgICAgICAgIC8vIHByb21pc2VkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IG51bGwgfHwgbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYXBwbHlcIjogZnVuY3Rpb24gKHRoaXNwLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpc3AsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBcImtleXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdF9rZXlzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZW5hYmxlcyB0byBRIHByb21pc2VzLlxuICogQHBhcmFtIHByb21pc2UgdGhlbmFibGUgcHJvbWlzZVxuICogQHJldHVybnMgYSBRIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gY29lcmNlKHByb21pc2UpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIEFubm90YXRlcyBhbiBvYmplY3Qgc3VjaCB0aGF0IGl0IHdpbGwgbmV2ZXIgYmVcbiAqIHRyYW5zZmVycmVkIGF3YXkgZnJvbSB0aGlzIHByb2Nlc3Mgb3ZlciBhbnkgcHJvbWlzZVxuICogY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgcHJvbWlzZSBhIHdyYXBwaW5nIG9mIHRoYXQgb2JqZWN0IHRoYXRcbiAqIGFkZGl0aW9uYWxseSByZXNwb25kcyB0byB0aGUgXCJpc0RlZlwiIG1lc3NhZ2VcbiAqIHdpdGhvdXQgYSByZWplY3Rpb24uXG4gKi9cblEubWFzdGVyID0gbWFzdGVyO1xuZnVuY3Rpb24gbWFzdGVyKG9iamVjdCkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJpc0RlZlwiOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKG9wLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBRKG9iamVjdCkuaW5zcGVjdCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFNwcmVhZHMgdGhlIHZhbHVlcyBvZiBhIHByb21pc2VkIGFycmF5IG9mIGFyZ3VtZW50cyBpbnRvIHRoZVxuICogZnVsZmlsbG1lbnQgY2FsbGJhY2suXG4gKiBAcGFyYW0gZnVsZmlsbGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdmFyaWFkaWMgYXJndW1lbnRzIGZyb20gdGhlXG4gKiBwcm9taXNlZCBhcnJheVxuICogQHBhcmFtIHJlamVjdGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGV4Y2VwdGlvbiBpZiB0aGUgcHJvbWlzZVxuICogaXMgcmVqZWN0ZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb3IgdGhyb3duIGV4Y2VwdGlvbiBvZlxuICogZWl0aGVyIGNhbGxiYWNrLlxuICovXG5RLnNwcmVhZCA9IHNwcmVhZDtcbmZ1bmN0aW9uIHNwcmVhZCh2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5zcHJlYWQoZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KTtcbiAgICB9LCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFRoZSBhc3luYyBmdW5jdGlvbiBpcyBhIGRlY29yYXRvciBmb3IgZ2VuZXJhdG9yIGZ1bmN0aW9ucywgdHVybmluZ1xuICogdGhlbSBpbnRvIGFzeW5jaHJvbm91cyBnZW5lcmF0b3JzLiAgQWx0aG91Z2ggZ2VuZXJhdG9ycyBhcmUgb25seSBwYXJ0XG4gKiBvZiB0aGUgbmV3ZXN0IEVDTUFTY3JpcHQgNiBkcmFmdHMsIHRoaXMgY29kZSBkb2VzIG5vdCBjYXVzZSBzeW50YXhcbiAqIGVycm9ycyBpbiBvbGRlciBlbmdpbmVzLiAgVGhpcyBjb2RlIHNob3VsZCBjb250aW51ZSB0byB3b3JrIGFuZCB3aWxsXG4gKiBpbiBmYWN0IGltcHJvdmUgb3ZlciB0aW1lIGFzIHRoZSBsYW5ndWFnZSBpbXByb3Zlcy5cbiAqXG4gKiBFUzYgZ2VuZXJhdG9ycyBhcmUgY3VycmVudGx5IHBhcnQgb2YgVjggdmVyc2lvbiAzLjE5IHdpdGggdGhlXG4gKiAtLWhhcm1vbnktZ2VuZXJhdG9ycyBydW50aW1lIGZsYWcgZW5hYmxlZC4gIFNwaWRlck1vbmtleSBoYXMgaGFkIHRoZW1cbiAqIGZvciBsb25nZXIsIGJ1dCB1bmRlciBhbiBvbGRlciBQeXRob24taW5zcGlyZWQgZm9ybS4gIFRoaXMgZnVuY3Rpb25cbiAqIHdvcmtzIG9uIGJvdGgga2luZHMgb2YgZ2VuZXJhdG9ycy5cbiAqXG4gKiBEZWNvcmF0ZXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gc3VjaCB0aGF0OlxuICogIC0gaXQgbWF5IHlpZWxkIHByb21pc2VzXG4gKiAgLSBleGVjdXRpb24gd2lsbCBjb250aW51ZSB3aGVuIHRoYXQgcHJvbWlzZSBpcyBmdWxmaWxsZWRcbiAqICAtIHRoZSB2YWx1ZSBvZiB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqICAtIGl0IHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlICh3aGVuIHRoZSBnZW5lcmF0b3JcbiAqICAgIHN0b3BzIGl0ZXJhdGluZylcbiAqICAtIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqICAgIG9mIHRoZSBnZW5lcmF0b3Igb3IgdGhlIGZpcnN0IHJlamVjdGVkIHByb21pc2UgYW1vbmcgdGhvc2VcbiAqICAgIHlpZWxkZWQuXG4gKiAgLSBpZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGdlbmVyYXRvciwgaXQgcHJvcGFnYXRlcyB0aHJvdWdoXG4gKiAgICBldmVyeSBmb2xsb3dpbmcgeWllbGQgdW50aWwgaXQgaXMgY2F1Z2h0LCBvciB1bnRpbCBpdCBlc2NhcGVzXG4gKiAgICB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFsdG9nZXRoZXIsIGFuZCBpcyB0cmFuc2xhdGVkIGludG8gYVxuICogICAgcmVqZWN0aW9uIGZvciB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgZGVjb3JhdGVkIGdlbmVyYXRvci5cbiAqL1xuUS5hc3luYyA9IGFzeW5jO1xuZnVuY3Rpb24gYXN5bmMobWFrZUdlbmVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInNlbmRcIiwgYXJnIGlzIGEgdmFsdWVcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwidGhyb3dcIiwgYXJnIGlzIGFuIGV4Y2VwdGlvblxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZXIodmVyYiwgYXJnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAvLyBVbnRpbCBWOCAzLjE5IC8gQ2hyb21pdW0gMjkgaXMgcmVsZWFzZWQsIFNwaWRlck1vbmtleSBpcyB0aGUgb25seVxuICAgICAgICAgICAgLy8gZW5naW5lIHRoYXQgaGFzIGEgZGVwbG95ZWQgYmFzZSBvZiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIFNNJ3MgZ2VuZXJhdG9ycyB1c2UgdGhlIFB5dGhvbi1pbnNwaXJlZCBzZW1hbnRpY3Mgb2ZcbiAgICAgICAgICAgIC8vIG91dGRhdGVkIEVTNiBkcmFmdHMuICBXZSB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgRVM2LCBidXQgd2UnZCBhbHNvXG4gICAgICAgICAgICAvLyBsaWtlIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGdlbmVyYXRvcnMgaW4gZGVwbG95ZWQgYnJvd3NlcnMsIHNvXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIHN1cHBvcnQgUHl0aG9uLXN0eWxlIGdlbmVyYXRvcnMuICBBdCBzb21lIHBvaW50IHdlIGNhbiByZW1vdmVcbiAgICAgICAgICAgIC8vIHRoaXMgYmxvY2suXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU3RvcEl0ZXJhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIEVTNiBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBRKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LnZhbHVlLCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTcGlkZXJNb25rZXkgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBSZW1vdmUgdGhpcyBjYXNlIHdoZW4gU00gZG9lcyBFUzYgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShleGNlcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdCwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBtYWtlR2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJuZXh0XCIpO1xuICAgICAgICB2YXIgZXJyYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJ0aHJvd1wiKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc3Bhd24gZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBhc3luYyB0aGF0IGltbWVkaWF0ZWx5XG4gKiBjYWxscyB0aGUgZ2VuZXJhdG9yIGFuZCBhbHNvIGVuZHMgdGhlIHByb21pc2UgY2hhaW4sIHNvIHRoYXQgYW55XG4gKiB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW5zdGVhZCBvZiBmb3J3YXJkZWQgdG8gdGhlIGVycm9yXG4gKiBoYW5kbGVyLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0J3MgZXh0cmVtZWx5IGNvbW1vbiB0byBydW5cbiAqIGdlbmVyYXRvcnMgYXQgdGhlIHRvcC1sZXZlbCB0byB3b3JrIHdpdGggbGlicmFyaWVzLlxuICovXG5RLnNwYXduID0gc3Bhd247XG5mdW5jdGlvbiBzcGF3bihtYWtlR2VuZXJhdG9yKSB7XG4gICAgUS5kb25lKFEuYXN5bmMobWFrZUdlbmVyYXRvcikoKSk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBpbnRlcmZhY2Ugb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuLyoqXG4gKiBUaHJvd3MgYSBSZXR1cm5WYWx1ZSBleGNlcHRpb24gdG8gc3RvcCBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIGEgc3RvcC1nYXAgbWVhc3VyZSB0byBzdXBwb3J0IGdlbmVyYXRvciByZXR1cm5cbiAqIHZhbHVlcyBpbiBvbGRlciBGaXJlZm94L1NwaWRlck1vbmtleS4gIEluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBFUzZcbiAqIGdlbmVyYXRvcnMgbGlrZSBDaHJvbWl1bSAyOSwganVzdCB1c2UgXCJyZXR1cm5cIiBpbiB5b3VyIGdlbmVyYXRvclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGUgc3Vycm91bmRpbmcgZ2VuZXJhdG9yXG4gKiBAdGhyb3dzIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB3aXRoIHRoZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzYgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24qICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgcmV0dXJuIGZvbyArIGJhcjtcbiAqIH0pXG4gKiAvLyBPbGRlciBTcGlkZXJNb25rZXkgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24gKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICBRLnJldHVybihmb28gKyBiYXIpO1xuICogfSlcbiAqL1xuUVtcInJldHVyblwiXSA9IF9yZXR1cm47XG5mdW5jdGlvbiBfcmV0dXJuKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFFSZXR1cm5WYWx1ZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIHByb21pc2VkIGZ1bmN0aW9uIGRlY29yYXRvciBlbnN1cmVzIHRoYXQgYW55IHByb21pc2UgYXJndW1lbnRzXG4gKiBhcmUgc2V0dGxlZCBhbmQgcGFzc2VkIGFzIHZhbHVlcyAoYHRoaXNgIGlzIGFsc28gc2V0dGxlZCBhbmQgcGFzc2VkXG4gKiBhcyBhIHZhbHVlKS4gIEl0IHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24gaXNcbiAqIGFsd2F5cyBhIHByb21pc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBhZGQgPSBRLnByb21pc2VkKGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgICAgcmV0dXJuIGEgKyBiO1xuICogfSk7XG4gKiBhZGQoUShhKSwgUShCKSk7XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGRlY29yYXRlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBkZWNvcmF0ZWQuXG4gKi9cblEucHJvbWlzZWQgPSBwcm9taXNlZDtcbmZ1bmN0aW9uIHByb21pc2VkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNwcmVhZChbdGhpcywgYWxsKGFyZ3VtZW50cyldLCBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vKipcbiAqIHNlbmRzIGEgbWVzc2FnZSB0byBhIHZhbHVlIGluIGEgZnV0dXJlIHR1cm5cbiAqIEBwYXJhbSBvYmplY3QqIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSBvcCB0aGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBvcGVyYXRpb24sIGUuZy4sIFwid2hlblwiLFxuICogQHBhcmFtIGFyZ3MgZnVydGhlciBhcmd1bWVudHMgdG8gYmUgZm9yd2FyZGVkIHRvIHRoZSBvcGVyYXRpb25cbiAqIEByZXR1cm5zIHJlc3VsdCB7UHJvbWlzZX0gYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAqL1xuUS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuZnVuY3Rpb24gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2gob3AsIGFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChvcCwgYXJncykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByb21pc2VEaXNwYXRjaChkZWZlcnJlZC5yZXNvbHZlLCBvcCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZ2V0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICovXG5RLmdldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIG9iamVjdCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSAgICAgbmV3IHZhbHVlIG9mIHByb3BlcnR5XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZGVsZXRlXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5kZWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIHZhbHVlICAgICBhIHZhbHVlIHRvIHBvc3QsIHR5cGljYWxseSBhbiBhcnJheSBvZlxuICogICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uIGFyZ3VtZW50cyBmb3IgcHJvbWlzZXMgdGhhdFxuICogICAgICAgICAgICAgICAgICBhcmUgdWx0aW1hdGVseSBiYWNrZWQgd2l0aCBgcmVzb2x2ZWAgdmFsdWVzLFxuICogICAgICAgICAgICAgICAgICBhcyBvcHBvc2VkIHRvIHRob3NlIGJhY2tlZCB3aXRoIFVSTHNcbiAqICAgICAgICAgICAgICAgICAgd2hlcmVpbiB0aGUgcG9zdGVkIHZhbHVlIGNhbiBiZSBhbnlcbiAqICAgICAgICAgICAgICAgICAgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cbi8vIGJvdW5kIGxvY2FsbHkgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IG90aGVyIG1ldGhvZHNcblEubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgaW52b2NhdGlvbiBhcmd1bWVudHNcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5Qcm9taXNlLnByb3RvdHlwZS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIGFyZ3MgICAgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYXBwbHkgPSBmdW5jdGlvbiAob2JqZWN0LCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUVtcInRyeVwiXSA9XG5RLmZjYWxsID0gZnVuY3Rpb24gKG9iamVjdCAvKiAuLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cyldKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uLCB0cmFuc2Zvcm1pbmcgcmV0dXJuIHZhbHVlcyBpbnRvIGEgZnVsZmlsbGVkXG4gKiBwcm9taXNlIGFuZCB0aHJvd24gZXJyb3JzIGludG8gYSByZWplY3RlZCBvbmUuXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZiaW5kID0gZnVuY3Rpb24gKG9iamVjdCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gUShvYmplY3QpO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblByb21pc2UucHJvdG90eXBlLmZiaW5kID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyB0aGUgbmFtZXMgb2YgdGhlIG93bmVkIHByb3BlcnRpZXMgb2YgYSBwcm9taXNlZFxuICogb2JqZWN0IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUga2V5cyBvZiB0aGUgZXZlbnR1YWxseSBzZXR0bGVkIG9iamVjdFxuICovXG5RLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkuICBJZiBhbnkgb2ZcbiAqIHRoZSBwcm9taXNlcyBnZXRzIHJlamVjdGVkLCB0aGUgd2hvbGUgYXJyYXkgaXMgcmVqZWN0ZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAqL1xuLy8gQnkgTWFyayBNaWxsZXJcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOmNvbmN1cnJlbmN5JnJldj0xMzA4Nzc2NTIxI2FsbGZ1bGZpbGxlZFxuUS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb21pc2UsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc25hcHNob3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXNQcm9taXNlKHByb21pc2UpICYmXG4gICAgICAgICAgICAgICAgKHNuYXBzaG90ID0gcHJvbWlzZS5pbnNwZWN0KCkpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSBzbmFwc2hvdC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytwZW5kaW5nQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hlbihcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLXBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHsgaW5kZXg6IGluZGV4LCB2YWx1ZTogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2Ugb2YgYW4gYXJyYXkuIFByaW9yIHJlamVjdGVkIHByb21pc2VzIGFyZVxuICogaWdub3JlZC4gIFJlamVjdHMgb25seSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIG9yIHByb21pc2VzIGZvciB2YWx1ZXNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2UsXG4gKiBvciBhIHJlamVjdGVkIHByb21pc2UgaWYgYWxsIHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAqL1xuUS5hbnkgPSBhbnk7XG5cbmZ1bmN0aW9uIGFueShwcm9taXNlcykge1xuICAgIGlmIChwcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFEucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZlcnJlZCA9IFEuZGVmZXIoKTtcbiAgICB2YXIgcGVuZGluZ0NvdW50ID0gMDtcbiAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VzW2luZGV4XTtcblxuICAgICAgICBwZW5kaW5nQ291bnQrKztcblxuICAgICAgICB3aGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcbiAgICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZWplY3RlZChlcnIpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciByZWplY3Rpb24gPSBlcnIgfHwgbmV3IEVycm9yKFwiXCIgKyBlcnIpO1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0aW9uLm1lc3NhZ2UgPSAoXCJRIGNhbid0IGdldCBmdWxmaWxsbWVudCB2YWx1ZSBmcm9tIGFueSBwcm9taXNlLCBhbGwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInByb21pc2VzIHdlcmUgcmVqZWN0ZWQuIExhc3QgZXJyb3IgbWVzc2FnZTogXCIgKyByZWplY3Rpb24ubWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVqZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvZ3Jlc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgdW5kZWZpbmVkKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyB0byBiZSBzZXR0bGVkLCBlaXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZC4gIFRoaXMgaXMgZGlzdGluY3QgZnJvbSBgYWxsYCBzaW5jZSB0aGF0IHdvdWxkIHN0b3BcbiAqIHdhaXRpbmcgYXQgdGhlIGZpcnN0IHJlamVjdGlvbi4gIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gKiBgYWxsUmVzb2x2ZWRgIHdpbGwgbmV2ZXIgYmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0gcHJvbWlzZXMgYSBwcm9taXNlIGZvciBhbiBhcnJheSAob3IgYW4gYXJyYXkpIG9mIHByb21pc2VzXG4gKiAob3IgdmFsdWVzKVxuICogQHJldHVybiBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHByb21pc2VzXG4gKi9cblEuYWxsUmVzb2x2ZWQgPSBkZXByZWNhdGUoYWxsUmVzb2x2ZWQsIFwiYWxsUmVzb2x2ZWRcIiwgXCJhbGxTZXR0bGVkXCIpO1xuZnVuY3Rpb24gYWxsUmVzb2x2ZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHByb21pc2VzID0gYXJyYXlfbWFwKHByb21pc2VzLCBRKTtcbiAgICAgICAgcmV0dXJuIHdoZW4oYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGVuKHByb21pc2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbFJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGxSZXNvbHZlZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQHNlZSBQcm9taXNlI2FsbFNldHRsZWRcbiAqL1xuUS5hbGxTZXR0bGVkID0gYWxsU2V0dGxlZDtcbmZ1bmN0aW9uIGFsbFNldHRsZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gUShwcm9taXNlcykuYWxsU2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGVpciBzdGF0ZXMgKGFzXG4gKiByZXR1cm5lZCBieSBgaW5zcGVjdGApIHdoZW4gdGhleSBoYXZlIGFsbCBzZXR0bGVkLlxuICogQHBhcmFtIHtBcnJheVtBbnkqXX0gdmFsdWVzIGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIHtBcnJheVtTdGF0ZV19IGFuIGFycmF5IG9mIHN0YXRlcyBmb3IgdGhlIHJlc3BlY3RpdmUgdmFsdWVzLlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxTZXR0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiBhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFEocHJvbWlzZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZWdhcmRsZXNzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmluc3BlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVnYXJkbGVzcywgcmVnYXJkbGVzcyk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIGZhaWx1cmUgb2YgYSBwcm9taXNlLCBnaXZpbmcgYW4gb3BvcnR1bml0eSB0byByZWNvdmVyXG4gKiB3aXRoIGEgY2FsbGJhY2suICBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICogcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpZiB0aGVcbiAqIGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2tcbiAqL1xuUS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9iamVjdCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgbGlzdGVuZXIgdGhhdCBjYW4gcmVzcG9uZCB0byBwcm9ncmVzcyBub3RpZmljYXRpb25zIGZyb20gYVxuICogcHJvbWlzZSdzIG9yaWdpbmF0aW5nIGRlZmVycmVkLiBUaGlzIGxpc3RlbmVyIHJlY2VpdmVzIHRoZSBleGFjdCBhcmd1bWVudHNcbiAqIHBhc3NlZCB0byBgYGRlZmVycmVkLm5vdGlmeWBgLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIHJlY2VpdmUgYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm5zIHRoZSBnaXZlbiBwcm9taXNlLCB1bmNoYW5nZWRcbiAqL1xuUS5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZnVuY3Rpb24gcHJvZ3Jlc3Mob2JqZWN0LCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhbiBvcHBvcnR1bml0eSB0byBvYnNlcnZlIHRoZSBzZXR0bGluZyBvZiBhIHByb21pc2UsXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIG9yIHJlamVjdGVkLiAgRm9yd2FyZHNcbiAqIHRoZSByZXNvbHV0aW9uIHRvIHRoZSByZXR1cm5lZCBwcm9taXNlIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGRvbmUuXG4gKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIHByb21pc2UgdG8gZGVmZXIgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gb2JzZXJ2ZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW5cbiAqIHByb21pc2UsIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2Ugd2hlblxuICogYGBmaW5gYCBpcyBkb25lLlxuICovXG5RLmZpbiA9IC8vIFhYWCBsZWdhY3lcblFbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpW1wiZmluYWxseVwiXShjYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maW4gPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjay5hcHBseSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3QgYXBwbHkgZmluYWxseSBjYWxsYmFja1wiKTtcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBRKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUT0RPIGF0dGVtcHQgdG8gcmVjeWNsZSB0aGUgcmVqZWN0aW9uIHdpdGggXCJ0aGlzXCIuXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGVybWluYXRlcyBhIGNoYWluIG9mIHByb21pc2VzLCBmb3JjaW5nIHJlamVjdGlvbnMgdG8gYmVcbiAqIHRocm93biBhcyBleGNlcHRpb25zLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGF0IHRoZSBlbmQgb2YgYSBjaGFpbiBvZiBwcm9taXNlc1xuICogQHJldHVybnMgbm90aGluZ1xuICovXG5RLmRvbmUgPSBmdW5jdGlvbiAob2JqZWN0LCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZG9uZShmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgdmFyIG9uVW5oYW5kbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gZm9yd2FyZCB0byBhIGZ1dHVyZSB0dXJuIHNvIHRoYXQgYGB3aGVuYGBcbiAgICAgICAgLy8gZG9lcyBub3QgY2F0Y2ggaXQgYW5kIHR1cm4gaXQgaW50byBhIHJlamVjdGlvbi5cbiAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgYG5leHRUaWNrYGluZyB2aWEgYW4gdW5uZWNlc3NhcnkgYHdoZW5gLlxuICAgIHZhciBwcm9taXNlID0gZnVsZmlsbGVkIHx8IHJlamVjdGVkIHx8IHByb2dyZXNzID9cbiAgICAgICAgdGhpcy50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSA6XG4gICAgICAgIHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgICBvblVuaGFuZGxlZEVycm9yID0gcHJvY2Vzcy5kb21haW4uYmluZChvblVuaGFuZGxlZEVycm9yKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4odm9pZCAwLCBvblVuaGFuZGxlZEVycm9yKTtcbn07XG5cbi8qKlxuICogQ2F1c2VzIGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCBpZiBpdCBkb2VzIG5vdCBnZXQgZnVsZmlsbGVkIGJlZm9yZVxuICogc29tZSBtaWxsaXNlY29uZHMgdGltZSBvdXQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHMgdGltZW91dFxuICogQHBhcmFtIHtBbnkqfSBjdXN0b20gZXJyb3IgbWVzc2FnZSBvciBFcnJvciBvYmplY3QgKG9wdGlvbmFsKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpZiBpdCBpc1xuICogZnVsZmlsbGVkIGJlZm9yZSB0aGUgdGltZW91dCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICovXG5RLnRpbWVvdXQgPSBmdW5jdGlvbiAob2JqZWN0LCBtcywgZXJyb3IpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRpbWVvdXQobXMsIGVycm9yKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIGVycm9yKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZXJyb3IgfHwgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvciB8fCBcIlRpbWVkIG91dCBhZnRlciBcIiArIG1zICsgXCIgbXNcIik7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgICAgfVxuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgIH0sIG1zKTtcblxuICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgIH0sIGRlZmVycmVkLm5vdGlmeSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBnaXZlbiB2YWx1ZSAob3IgcHJvbWlzZWQgdmFsdWUpLCBzb21lXG4gKiBtaWxsaXNlY29uZHMgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFBhc3NlcyByZWplY3Rpb25zIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGFmdGVyIG1pbGxpc2Vjb25kc1xuICogdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZS5cbiAqIElmIHRoZSBnaXZlbiBwcm9taXNlIHJlamVjdHMsIHRoYXQgaXMgcGFzc2VkIGltbWVkaWF0ZWx5LlxuICovXG5RLmRlbGF5ID0gZnVuY3Rpb24gKG9iamVjdCwgdGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZW91dCA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gUShvYmplY3QpLmRlbGF5KHRpbWVvdXQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgYXMgYW4gYXJyYXksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiAgICAgIFEubmZhcHBseShGUy5yZWFkRmlsZSwgW19fZmlsZW5hbWVdKVxuICogICAgICAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogICAgICB9KVxuICpcbiAqL1xuUS5uZmFwcGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBpbmRpdmlkdWFsbHksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mY2FsbChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSlcbiAqIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiB9KVxuICpcbiAqL1xuUS5uZmNhbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFdyYXBzIGEgTm9kZUpTIGNvbnRpbnVhdGlvbiBwYXNzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFuIGVxdWl2YWxlbnRcbiAqIHZlcnNpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mYmluZChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSkoXCJ1dGYtOFwiKVxuICogLnRoZW4oY29uc29sZS5sb2cpXG4gKiAuZG9uZSgpXG4gKi9cblEubmZiaW5kID1cblEuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUSBjYW4ndCB3cmFwIGFuIHVuZGVmaW5lZCBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgUShjYWxsYmFjaykuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmJpbmQgPVxuUHJvbWlzZS5wcm90b3R5cGUuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5kZW5vZGVpZnkuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cblEubmJpbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc3AsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgUShib3VuZCkuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uYmluZCA9IGZ1bmN0aW9uICgvKnRoaXNwLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMCk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLm5iaW5kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2sgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkIGNhbGxiYWNrLlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEubnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ucG9zdChuYW1lLCBhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUubnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MgfHwgW10pO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjaywgZm9yd2FyZGluZyB0aGUgZ2l2ZW4gdmFyaWFkaWMgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWRcbiAqIGNhbGxiYWNrIGFyZ3VtZW50LlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIC4uLmFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrIHdpbGxcbiAqIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5RLm5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblByb21pc2UucHJvdG90eXBlLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblByb21pc2UucHJvdG90eXBlLm5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBJZiBhIGZ1bmN0aW9uIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBib3RoIE5vZGUgY29udGludWF0aW9uLXBhc3Npbmctc3R5bGUgYW5kXG4gKiBwcm9taXNlLXJldHVybmluZy1zdHlsZSwgaXQgY2FuIGVuZCBpdHMgaW50ZXJuYWwgcHJvbWlzZSBjaGFpbiB3aXRoXG4gKiBgbm9kZWlmeShub2RlYmFjaylgLCBmb3J3YXJkaW5nIHRoZSBvcHRpb25hbCBub2RlYmFjayBhcmd1bWVudC4gIElmIHRoZSB1c2VyXG4gKiBlbGVjdHMgdG8gdXNlIGEgbm9kZWJhY2ssIHRoZSByZXN1bHQgd2lsbCBiZSBzZW50IHRoZXJlLiAgSWYgdGhleSBkbyBub3RcbiAqIHBhc3MgYSBub2RlYmFjaywgdGhleSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBwcm9taXNlLlxuICogQHBhcmFtIG9iamVjdCBhIHJlc3VsdCAob3IgYSBwcm9taXNlIGZvciBhIHJlc3VsdClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5vZGViYWNrIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFja1xuICogQHJldHVybnMgZWl0aGVyIHRoZSBwcm9taXNlIG9yIG5vdGhpbmdcbiAqL1xuUS5ub2RlaWZ5ID0gbm9kZWlmeTtcbmZ1bmN0aW9uIG5vZGVpZnkob2JqZWN0LCBub2RlYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdCkubm9kZWlmeShub2RlYmFjayk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2spIHtcbiAgICBpZiAobm9kZWJhY2spIHtcbiAgICAgICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblEubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlEubm9Db25mbGljdCBvbmx5IHdvcmtzIHdoZW4gUSBpcyB1c2VkIGFzIGEgZ2xvYmFsXCIpO1xufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcbiJdLCJuYW1lcyI6WyJkZWZpbml0aW9uIiwiYm9vdHN0cmFwIiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsInNlcyIsIm9rIiwibWFrZVEiLCJzZWxmIiwiZ2xvYmFsIiwid2luZG93IiwicHJldmlvdXNRIiwiUSIsIm5vQ29uZmxpY3QiLCJFcnJvciIsImhhc1N0YWNrcyIsImUiLCJzdGFjayIsInFTdGFydGluZ0xpbmUiLCJjYXB0dXJlTGluZSIsInFGaWxlTmFtZSIsIm5vb3AiLCJuZXh0VGljayIsImhlYWQiLCJ0YXNrIiwibmV4dCIsInRhaWwiLCJmbHVzaGluZyIsInJlcXVlc3RUaWNrIiwiaXNOb2RlSlMiLCJsYXRlclF1ZXVlIiwiZmx1c2giLCJkb21haW4iLCJlbnRlciIsInJ1blNpbmdsZSIsImxlbmd0aCIsInBvcCIsImV4aXQiLCJzZXRUaW1lb3V0IiwicHJvY2VzcyIsInRvU3RyaW5nIiwic2V0SW1tZWRpYXRlIiwiYmluZCIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicmVxdWVzdFBvcnRUaWNrIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsInJ1bkFmdGVyIiwicHVzaCIsImNhbGwiLCJGdW5jdGlvbiIsInVuY3VycnlUaGlzIiwiZiIsImFwcGx5IiwiYXJndW1lbnRzIiwiYXJyYXlfc2xpY2UiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiYXJyYXlfcmVkdWNlIiwicmVkdWNlIiwiY2FsbGJhY2siLCJiYXNpcyIsImluZGV4IiwiVHlwZUVycm9yIiwiYXJyYXlfaW5kZXhPZiIsImluZGV4T2YiLCJ2YWx1ZSIsImkiLCJhcnJheV9tYXAiLCJtYXAiLCJ0aGlzcCIsImNvbGxlY3QiLCJ1bmRlZmluZWQiLCJvYmplY3RfY3JlYXRlIiwiT2JqZWN0IiwiY3JlYXRlIiwiVHlwZSIsIm9iamVjdF9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwicHJvcCIsImRlc2NyaXB0b3IiLCJvYmplY3RfaGFzT3duUHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsIm9iamVjdF9rZXlzIiwia2V5cyIsIm9iamVjdCIsImtleSIsIm9iamVjdF90b1N0cmluZyIsImlzT2JqZWN0IiwiaXNTdG9wSXRlcmF0aW9uIiwiZXhjZXB0aW9uIiwiUVJldHVyblZhbHVlIiwiUmV0dXJuVmFsdWUiLCJTVEFDS19KVU1QX1NFUEFSQVRPUiIsIm1ha2VTdGFja1RyYWNlTG9uZyIsImVycm9yIiwicHJvbWlzZSIsInN0YWNrcyIsInAiLCJzb3VyY2UiLCJfX21pbmltdW1TdGFja0NvdW50ZXJfXyIsInN0YWNrQ291bnRlciIsImNvbmZpZ3VyYWJsZSIsInVuc2hpZnQiLCJjb25jYXRlZFN0YWNrcyIsImpvaW4iLCJmaWx0ZXJTdGFja1N0cmluZyIsInN0YWNrU3RyaW5nIiwibGluZXMiLCJzcGxpdCIsImRlc2lyZWRMaW5lcyIsImxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJpc05vZGVGcmFtZSIsInN0YWNrTGluZSIsImdldEZpbGVOYW1lQW5kTGluZU51bWJlciIsImF0dGVtcHQxIiwiZXhlYyIsIk51bWJlciIsImF0dGVtcHQyIiwiYXR0ZW1wdDMiLCJmaWxlTmFtZUFuZExpbmVOdW1iZXIiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJxRW5kaW5nTGluZSIsImZpcnN0TGluZSIsImRlcHJlY2F0ZSIsIm5hbWUiLCJhbHRlcm5hdGl2ZSIsImNvbnNvbGUiLCJ3YXJuIiwiUHJvbWlzZSIsImlzUHJvbWlzZUFsaWtlIiwiY29lcmNlIiwiZnVsZmlsbCIsInJlc29sdmUiLCJsb25nU3RhY2tTdXBwb3J0IiwibG9uZ1N0YWNrQ291bnRlciIsImVudiIsIlFfREVCVUciLCJkZWZlciIsIm1lc3NhZ2VzIiwicHJvZ3Jlc3NMaXN0ZW5lcnMiLCJyZXNvbHZlZFByb21pc2UiLCJkZWZlcnJlZCIsInByb21pc2VEaXNwYXRjaCIsIm9wIiwib3BlcmFuZHMiLCJhcmdzIiwidmFsdWVPZiIsIm5lYXJlclZhbHVlIiwibmVhcmVyIiwiaXNQcm9taXNlIiwiaW5zcGVjdCIsInN0YXRlIiwic3Vic3RyaW5nIiwiYmVjb21lIiwibmV3UHJvbWlzZSIsIm1lc3NhZ2UiLCJyZWplY3QiLCJyZWFzb24iLCJub3RpZnkiLCJwcm9ncmVzcyIsInByb2dyZXNzTGlzdGVuZXIiLCJtYWtlTm9kZVJlc29sdmVyIiwicmVzb2x2ZXIiLCJyYWNlIiwiYWxsIiwicGFzc0J5Q29weSIsIngiLCJ5IiwidGhhdCIsInNwcmVhZCIsImFuc3dlclBzIiwibGVuIiwidGhlbiIsIm1ha2VQcm9taXNlIiwiZmFsbGJhY2siLCJyZXN1bHQiLCJpbnNwZWN0ZWQiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsInByb2dyZXNzZWQiLCJkb25lIiwiX2Z1bGZpbGxlZCIsIl9yZWplY3RlZCIsIm5ld0V4Y2VwdGlvbiIsIl9wcm9ncmVzc2VkIiwibmV3VmFsdWUiLCJ0aHJldyIsIm9uZXJyb3IiLCJ0YXAiLCJmY2FsbCIsInRoZW5SZXNvbHZlIiwid2hlbiIsInRoZW5SZWplY3QiLCJpc1BlbmRpbmciLCJpc0Z1bGZpbGxlZCIsImlzUmVqZWN0ZWQiLCJ1bmhhbmRsZWRSZWFzb25zIiwidW5oYW5kbGVkUmVqZWN0aW9ucyIsInJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucyIsInRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyIsInJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucyIsInRyYWNrUmVqZWN0aW9uIiwiZW1pdCIsInVudHJhY2tSZWplY3Rpb24iLCJhdCIsImF0UmVwb3J0Iiwic3BsaWNlIiwiZ2V0VW5oYW5kbGVkUmVhc29ucyIsInN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyIsInJlamVjdGlvbiIsInJocyIsIm1hc3RlciIsImRpc3BhdGNoIiwiYXJyYXkiLCJhc3luYyIsIm1ha2VHZW5lcmF0b3IiLCJjb250aW51ZXIiLCJ2ZXJiIiwiYXJnIiwiU3RvcEl0ZXJhdGlvbiIsImdlbmVyYXRvciIsImVycmJhY2siLCJzcGF3biIsIl9yZXR1cm4iLCJwcm9taXNlZCIsImdldCIsInNldCIsImRlbCIsIm1hcHBseSIsInBvc3QiLCJzZW5kIiwibWNhbGwiLCJpbnZva2UiLCJmYXBwbHkiLCJmYmluZCIsImZib3VuZCIsImNvbmNhdCIsInByb21pc2VzIiwicGVuZGluZ0NvdW50Iiwic25hcHNob3QiLCJhbnkiLCJwcmV2IiwiY3VycmVudCIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsIm9uUHJvZ3Jlc3MiLCJlcnIiLCJhbGxSZXNvbHZlZCIsImFsbFNldHRsZWQiLCJyZWdhcmRsZXNzIiwiZmFpbCIsImZpbiIsIm9uVW5oYW5kbGVkRXJyb3IiLCJ0aW1lb3V0IiwibXMiLCJ0aW1lb3V0SWQiLCJjb2RlIiwiY2xlYXJUaW1lb3V0IiwiZGVsYXkiLCJuZmFwcGx5Iiwibm9kZUFyZ3MiLCJuZmNhbGwiLCJuZmJpbmQiLCJkZW5vZGVpZnkiLCJiYXNlQXJncyIsIm5iaW5kIiwiYm91bmQiLCJubWFwcGx5IiwibnBvc3QiLCJuc2VuZCIsIm5tY2FsbCIsIm5pbnZva2UiLCJub2RlaWZ5Iiwibm9kZWJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/q/q.js\n");

/***/ })

};
;